
//import std/io::println
//import std/memory::assert

shape Node(
    val: i32,
    ~?next: Node
)
impl Node {
    fn unwrap(~?self: Node) -> &Node <- self {
        if ~?self is ~self {
            return &self
        }
        //assert(false, "unwrap null")
        return &self
    }
}

fn unwrap(~?p: Node) -> &Node <- p {
    if ~?p is ~p {
        return &p
    }
    //assert(false, "unwrap null")
    return &p
}

pub fn main() -> i32 {
    auto count = 10
    // User's logic + Print checks
    auto ~#head = new Node(val=1, ~?next=nullptr)  
    //println("head: {}", head.val)
    //assert(head.val == 0, "check head.val")
    // Push 1
    {
        auto i# = 1
        loop {
            auto ~next = ~head
            ~#head = new Node(val=1, ~?next=~next)
            //println("[{}]pushed: {}", i, head.val)
            //assert(head.val == i, "check head.val")
            if i == count + 1 {
                break
            }
            i# += 1            
        }
    }
    
    // 使用共享指针游标，前缀为 # (可重绑定)，后缀为 $ (只读)
    auto ~#cursor = ~head 
    auto i# = count + 1
    auto sum# = 0:i64
    loop {
        //assert(i >= 0, "check i >= 0")
        //println("[{}]val: {}", i, cursor.val)
        //assert(cursor.val == i, "check cursor.val")
        if i == 1 {
            break
        }

        sum# += cursor.val:i64
        
        i# -= 1        
        // 尝试获取下一个节点
        if cursor.~?next is cursor.~next {
            ~#cursor = cursor.~next // 重绑定句柄，RC 自动处理
        } else {
            break
        }
    }
    //println("Sum: {}", sum)
    return 0
}