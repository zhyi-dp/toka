// ==========================================
// Toka Standard Library: String
// Version: 1.3.1 (In-Place Capture & Strict Morphology)
// ==========================================

import core/types::{char,usize,Addr,ADDR0}

// ------------------------------------------------------
// 1. External C Interface (libc)
// ------------------------------------------------------
// 外部定义严格遵循 Toka 形态：*ptr: type
// 含义：ptr 是 type 类型的实体，但我们通过指针操作它。

extern fn libc_malloc(size: usize) -> *void
extern fn libc_realloc(*ptr: void, size: usize) -> *void
extern fn libc_free(*ptr: void) -> void
extern fn libc_memcpy(*dest: void, *src: void, n: usize) -> *void
extern fn libc_strlen(*s: char) -> usize


// ------------------------------------------------------
// 2. Shape Definition
// ------------------------------------------------------

pub shape String (
    // Slot A (*#): 允许修改指针指向 (realloc 需要)
    // Slot B (#) : 允许修改指向的数据 (memcpy 需要)
    *buf#: char, //不需要写成 *#buf#，因为 被含指针的可绑定性继承自String实例的可变性（也就是fn中的self的可变性），相当于rust的 *mut T 成员
    
    len: i32,
    cap: i32
)


// ------------------------------------------------------
// 3. Implementation
// ------------------------------------------------------

impl String {

    // === 构造函数 ===

    pub fn new() -> String {
        unsafe {
            // libc_malloc 返回 *void 地址，强转为 *char 地址
            auto *p# = libc_malloc(1:usize) as *char
            
            // 初始化数据：p 代表实体
            p#[0] = 0 as char
            
            return String(
                *buf = *p, // 赋值给 Slot A (地址) 初始化时无视权限 不需要出示#
                len = 0, 
                cap = 1
            )
        }
    }

    pub fn from(*s: char) -> String {
        unsafe {
            // 传入地址 *s
            auto l = libc_strlen(*s)
            
            // 声明本地指针 p，持有可写权限 #
            auto *p# = libc_malloc((l + 1) as usize) as *char
            
            // 内存拷贝：传入地址
            libc_memcpy(*p as *void, *s as *void, l)
            
            // Null Terminate
            p#[l] = 0 as char
            
            return String(
                *buf = *p, // 赋值给 Slot A (地址) 初始化时无视权限 不需要出示#
                len = l as i32,
                cap = (l + 1) as i32
            )
        }
    }

    // === 访问器 (View) ===
    
    // [原地捕获] self 代表实例本身，默认只读
    pub fn len(self) -> i32 {
        return self.len
    }

    pub fn capacity(self) -> i32 {
        return self.cap
    }

    pub fn c_str(self) -> *char {
        // self.*buf 访问的是 buf 指针变量里存储的地址 (Slot A)
        return self.*buf as *char
    }
    
    // === 修改器 (Mutation) ===

    // [原地捕获] self# 代表可变实例
    // 允许修改 self.len, self.cap 以及 self.*buf (重定向指针)
    pub fn push_str(self#, *s: char) -> i32 {
        unsafe {
            auto slen = libc_strlen(*s)
            auto needed = self.len + (slen as i32)
            
            // 1. 扩容逻辑
            if needed >= self.cap {
                auto new_cap = (self.cap * 2) + (slen as i32) + 1
                
                // realloc 需要传入旧地址：self.*buf
                auto *tmp = libc_realloc(self.*buf as *void, new_cap as usize) as *char
                
                if *tmp == (0 as *char) {
                    return 0;
                }
                
                // 修改实例成员：将新地址赋值给 buf (Slot A)
                // 因为 self# 是可变的，且 buf 定义为 *#buf，所以合法
                self#.*buf = *tmp
                self#.cap = new_cap
            }
            
            // 2. 拼接逻辑
            // 计算目标地址：基地址(self.*buf) + 偏移
            auto *dst# = (self.*buf as usize + self.len as usize) as *char
            
            // 拷贝数据
            libc_memcpy(*dst as *void, *s as *void, slen)
            
            // 更新长度
            self#.len = needed
            
            // Null Terminate
            dst#[slen] = 0 as char
        }
        return 1
    }

    // === 析构 (Destructor) ===

    pub fn drop(self#) {
        unsafe {
            if self.*buf != nullptr {
                // 释放内存地址
                libc_free(self.*buf as *void)
                
                // 置空：修改 Slot A
                self#.*buf = nullptr 
            }
        }
    }
}