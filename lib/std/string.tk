// Copyright (c) 2025 YiZhonghua<zhyi@dpai.com>. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ==========================================
// Toka Standard Library: String
// Version: 1.3.1 (In-Place Capture & Strict Morphology)
// ==========================================

import core/types::{char,usize,Addr,ADDR0}
import core/traits::{@encap}

// ------------------------------------------------------
// 1. External C Interface (libc)
// ------------------------------------------------------

extern fn libc_malloc(size: usize) -> *void
extern fn libc_realloc(*ptr: void, size: usize) -> *void
extern fn libc_free(*ptr: void) -> void
extern fn libc_memcpy(*dest: void, *src: void, n: usize) -> *void
extern fn libc_strlen(*s: char) -> usize
extern fn libc_sprintf(*dest: char, *format: char, ...) -> usize


// ------------------------------------------------------
// 2. Shape Definition
// ------------------------------------------------------

pub shape String (
    *buf#: char,
    len: i32,
    cap: i32
)

impl String@encap {
    pub cap
    fn drop(self#) {
        unsafe {
            if self.*buf != nullptr {
                libc_free(self.*buf as *void)
                self#.*buf = nullptr 
                self#.len = 0
                self#.cap = 0
            }
        }
    }
}

// ------------------------------------------------------
// 3. Iterators
// ------------------------------------------------------

pub shape SplitIterator (
    *source: char,
    source_len: i32,
    current_pos: i32,
    delimiter: char
)

impl SplitIterator {
    pub fn next(self#) -> String {
        unsafe {
             if self.current_pos >= self.source_len {
                 return String::from("") 
             }
             
             auto start = self.current_pos
             auto found# = false
             auto i# = start
             
             while i < self.source_len {
                 // dereference
                 if self.source[i] == self.delimiter {
                     found# = true
                     break
                 }
                 i# = i + 1
             }
             
             auto end = i
             auto len = end - start
             
             // Update iterator state
             if found {
                 self#.current_pos = end + 1
             } else {
                 self#.current_pos = self.source_len + 1 // Done
             }
             
             // Extract substring
             auto *start_ptr = self.*source + start
             return String::from_with_len(*start_ptr, len)
        }
    }
    
    pub fn is_done(self) -> bool {
        return self.current_pos > self.source_len
    }
}


// ------------------------------------------------------
// 4. String Implementation
// ------------------------------------------------------

impl String {

    // === Constructors ===

    pub fn from(*s: char) -> String {
        unsafe {
            auto l = libc_strlen(*s)
            auto *p# = libc_malloc((l + 1) as usize) as *char
            libc_memcpy(*p as *void, *s as *void, l)
            p#[l] = 0 as char
            
            return String(
                *buf = *p,
                len = l as i32,
                cap = (l + 1) as i32
            )
        }
    }
    
    // Internal helper for substrings
    pub fn from_with_len(*s: char, len: i32) -> String {
        unsafe {
            auto l = len
            auto *p# = libc_malloc((l + 1) as usize) as *char
            libc_memcpy(*p as *void, *s as *void, l as usize)
            p#[l] = 0 as char
            
            return String(
                *buf = *p,
                len = l,
                cap = l + 1
            )
        }
    }

    // === Converters ===

    pub fn from_int(val: i32) -> String {
        unsafe {
            // Max i32 chars is 11 (-2147483648) + null
            auto *buf# = libc_malloc(16) as *char
            libc_sprintf(*buf, "%d", val)
            auto len = libc_strlen(*buf)
            
            return String(
                *buf = *buf,
                len = len as i32,
                cap = 16
            )
        }
    }

    pub fn from_i64(val: i64) -> String {
        unsafe {
            auto *buf# = libc_malloc(32) as *char
            libc_sprintf(*buf, "%lld", val)
            auto len = libc_strlen(*buf)
            return String(*buf = *buf, len = len as i32, cap = 32)
        }
    }
    
    pub fn from_f64(val: f64) -> String {
         unsafe {
            auto *buf# = libc_malloc(32) as *char
            libc_sprintf(*buf, "%.6f", val)
            auto len = libc_strlen(*buf)
            return String(*buf = *buf, len = len as i32, cap = 32)
        }
    }

    // === View ===
    
    pub fn len(self) -> i32 {
        return self.len
    }

    pub fn capacity(self) -> i32 {
        return self.cap
    }

    pub fn c_str(self) -> *char {
        return self.*buf as *char
    }
    
    // === Mutation ===

    pub fn push_str(self#, *s: char) -> i32 {
        unsafe {
            auto slen = libc_strlen(*s)
            auto needed = self.len + (slen as i32)
            
            if needed >= self.cap {
                auto new_cap = (self.cap * 2) + (slen as i32) + 1
                auto *tmp = libc_realloc(self.*buf as *void, new_cap as usize) as *char
                if *tmp == (0 as *char) { return 0 }
                self#.*buf = *tmp
                self#.cap = new_cap
            }
            
            auto *dst# = (self.*buf as usize + self.len as usize) as *char
            libc_memcpy(*dst as *void, *s as *void, slen)
            self#.len = needed
            dst#[slen] = 0 as char
        }
        return 1
    }

    pub fn push_char(self#, c: char) -> i32 {
        unsafe {
            auto needed = self.len + 1
            
            if needed >= self.cap {
                auto new_cap = (self.cap * 2) + 2
                auto *tmp = libc_realloc(self.*buf as *void, new_cap as usize) as *char
                if *tmp == (0 as *char) { return 0 }
                self#.*buf = *tmp
                self#.cap = new_cap
            }
            
            auto *dst# = (self.*buf as usize + self.len as usize) as *char
            dst#[0] = c
            dst#[1] = 0 as char
            self#.len = needed
        }
        return 1
    }

    pub fn eq(self, other: String) -> bool {
        unsafe {
            if self.len != other.len() { return false }
            auto i# = 0
            auto *b1 = self.c_str()
            auto *b2 = other.c_str()
            while i < self.len {
                auto *p1 = (b1 as usize + i as usize) as *char
                auto *p2 = (b2 as usize + i as usize) as *char
                if *p1 != *p2 { return false }
                i# = i + 1
            }
            return true
        }
    }

    pub fn clear(self#) {
        self#.drop()
    }
    
    // === Utilities ===
    
    fn is_whitespace(c: char) -> bool {
        if c == 32 as char { return true } // space
        if c == 9 as char { return true }  // tab
        if c == 10 as char { return true } // newline
        if c == 13 as char { return true } // cr
        return false
    }

    pub fn trim(self) -> String {
        unsafe {
            auto start# = 0
            auto end# = self.len - 1
            auto *raw = self.c_str()
            
            // Find start
            while start < self.len {
                // Manual pointer access
                auto p = raw[start]
                if !String::is_whitespace(p) {
                    break
                }
                start# = start + 1
            }
            
            // Find end
            while end >= start {
                auto p = raw[end]
                if !String::is_whitespace(p) {
                    break
                }
                end# = end - 1
            }
            
            auto new_len = end - start + 1
            if new_len <= 0 {
                return String::from("")
            }
            
            auto *sub_start = *raw[start]
            return String::from_with_len(*sub_start, new_len)
        }
    }
    
    // delim as i32 to avoid ABI char passing issues
    pub fn split(self, delim: i32) -> SplitIterator {
        return SplitIterator(
            *source = self.c_str(),
            source_len = self.len,
            current_pos = 0,
            delimiter = delim as char
        )
    }
}