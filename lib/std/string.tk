// Copyright (c) 2025 YiZhonghua<zhyi@dpai.com>. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ==========================================
// Toka Standard Library: String
// Version: 1.3.1 (In-Place Capture & Strict Morphology)
// ==========================================

import core/types::{char, usize, Addr, ADDR0}
import core/traits::{@encap, @Hash}
import core/libc::*


// ------------------------------------------------------
// 2. Shape Definition
// ------------------------------------------------------

pub shape String (
    *buf#: char,
    len: i32,
    cap: i32
)

impl String@encap {
    pub cap
    fn clone(self) -> String {
        return String::from_with_len(self.c_str(), self.len)
    }

    fn drop(self#) {
        unsafe {
            if self.*buf != nullptr {
                // libc_free(self.*buf as *void)
                self.*buf = nullptr 
                self.len = 0
                self.cap = 0
            }
        }
    }
}

// ------------------------------------------------------
// 3. Iterators
// ------------------------------------------------------

pub shape SplitIterator (
    *source: char,
    source_len: i32,
    current_pos#: i32,
    delimiter: char
)

impl SplitIterator@encap {
    fn drop(self#) {
        // Observer only, no resource to free
    }
    
    fn clone(self) -> SplitIterator {
        return SplitIterator(
             *source = self.*source,
             source_len = self.source_len,
             current_pos = self.current_pos,
             delimiter = self.delimiter
        )
    }
}

impl SplitIterator {
    pub fn next(self) -> String {
        unsafe {
             if self.current_pos >= self.source_len {
                 self.current_pos = self.source_len + 1
                 return String::from("") 
             }
             
             auto start = self.current_pos
             auto found# = false
             auto i# = start
             
             while i < self.source_len {
                 // dereference
                 if self.source[i] == self.delimiter {
                     found = true
                     break
                 }
                 i = i + 1
             }
             
             auto end = i
             auto len = end - start
             
             // Update iterator state
             if found {
                 self.current_pos = end + 1
             } else {
                 self.current_pos = self.source_len + 1 // Done
             }
             
             // Extract substring
             auto *start_ptr = self.*source + start
             return String::from_with_len(*start_ptr, len)
        }
    }
    
    pub fn is_done(self) -> bool {
        return self.current_pos > self.source_len
    }
}


// ------------------------------------------------------
// 4. String Implementation
// ------------------------------------------------------

impl String {

    // === Constructors ===

    pub fn from(*s: char) -> String {
        unsafe {
            auto l = libc_strlen(*s)
            auto *p# = libc_malloc((l + 1) as usize) as *char
            libc_memcpy(*p as *void, *s as *void, l)
            p[l] = 0 as char
            
            return String(
                *buf = *p,
                len = l as i32,
                cap = (l + 1) as i32
            )
        }
    }
    
    // Internal helper for substrings
    pub fn from_with_len(*s: char, len: i32) -> String {
        unsafe {
            auto l = len
            auto *p# = libc_malloc((l + 1) as usize) as *char
            libc_memcpy(*p as *void, *s as *void, l as usize)
            p[l] = 0 as char
            
            return String(
                *buf = *p,
                len = l,
                cap = l + 1
            )
        }
    }

    // === Converters ===

    /**
     * Creates a String from a C-string and frees the input pointer.
     * Useful for FFI functions returning allocated strings.
     */
    pub fn from_take(*s: char) -> String {
        unsafe {
            libc_write(2, "DEBUG: from_take entry\n" as *u8, 23)
            auto l = libc_strlen(*s)
            
            libc_write(2, "DEBUG: from_take strlen done\n" as *u8, 29)
            
            auto *p# = libc_malloc((l + 1) as usize) as *char
            libc_memcpy(*p as *void, *s as *void, l)
            p[l] = 0 as char
            
            // Free the input pointer (take ownership)
            // libc_free(*s as *void)
            
            libc_write(2, "DEBUG: from_take free skipped\n" as *u8, 30)
            
            return String(
                *buf = *p,
                len = l as i32,
                cap = (l + 1) as i32
            )
        }
    }

    // pub fn clone(self) -> String {
    //     return String::from_with_len(self.c_str(), self.len)
    // }

    pub fn from_int(val: i32) -> String {
        unsafe {
            // Max i32 chars is 11 (-2147483648) + null
            auto *buf# = libc_malloc(16) as *char
            libc_sprintf(*buf, "%d", val)
            auto len = libc_strlen(*buf)
            
            return String(
                *buf = *buf,
                len = len as i32,
                cap = 16
            )
        }
    }

    pub fn from_i64(val: i64) -> String {
        unsafe {
            auto *buf# = libc_malloc(32) as *char
            libc_sprintf(*buf, "%lld", val)
            auto len = libc_strlen(*buf)
            return String(*buf = *buf, len = len as i32, cap = 32)
        }
    }
    
    pub fn from_f64(val: f64) -> String {
         unsafe {
            auto *buf# = libc_malloc(32) as *char
            libc_sprintf(*buf, "%.6f", val)
            auto len = libc_strlen(*buf)
            return String(*buf = *buf, len = len as i32, cap = 32)
        }
    }

    // === View ===
    
    pub fn len(self) -> i32 {
        return self.len
    }

    pub fn capacity(self) -> i32 {
        return self.cap
    }

    pub fn c_str(self) -> *char {
        return self.*buf as *char
    }
    
    // === Mutation ===

    pub fn push_str(self#, *s: char) -> i32 {
        unsafe {
            auto slen = libc_strlen(*s)
            auto needed = self.len + (slen as i32)
            
            if needed >= self.cap {
                auto new_cap = (self.cap * 2) + (slen as i32) + 1
                auto *tmp = libc_realloc(self.*buf as *void, new_cap as usize) as *char
                if *tmp == (0 as *char) { return 0 }
                self.*buf = *tmp
                self.cap = new_cap
            }
            
            auto *dst# = (self.*buf as usize + self.len as usize) as *char
            libc_memcpy(*dst as *void, *s as *void, slen)
            self.len = needed
            dst[slen] = 0 as char
        }
        return 1
    }

    pub fn push_char(self#, c: char) -> i32 {
        unsafe {
            auto needed = self.len + 1
            
            if needed >= self.cap {
                auto new_cap = (self.cap * 2) + 2
                auto *tmp = libc_realloc(self.*buf as *void, new_cap as usize) as *char
                if *tmp == (0 as *char) { return 0 }
                self.*buf = *tmp
                self.cap = new_cap
            }
            
            auto *dst# = (self.*buf as usize + self.len as usize) as *char
            dst[0] = c
            dst[1] = 0 as char
            self.len = needed
        }
        return 1
    }

    pub fn eq(self, other: String) -> bool {
        unsafe {
            if self.len != other.len() { return false }
            auto i# = 0
            auto *b1 = self.c_str()
            auto *b2 = other.c_str()
            while i < self.len {
                auto *p1 = (b1 as usize + i as usize) as *char
                auto *p2 = (b2 as usize + i as usize) as *char
                if *p1 != *p2 { return false }
                i = i + 1
            }
            return true
        }
    }

    pub fn clear(self#) {
        unsafe {
            self.len = 0
            if self.*buf != nullptr {
                self.buf[0] = 0 as char
            }
        }
    }

    pub fn unsafe_forget(self#) {
        unsafe {
            self.*buf = nullptr
            self.len = 0
            self.cap = 0
        }
    }
    
    // === Utilities ===
    
    fn is_whitespace(c: char) -> bool {
        if c == 32 as char { return true } // space
        if c == 9 as char { return true }  // tab
        if c == 10 as char { return true } // newline
        if c == 13 as char { return true } // cr
        return false
    }

    pub fn trim(self) -> String {
        unsafe {
            auto start# = 0
            auto end# = self.len - 1
            auto *raw = self.c_str()
            
            // Find start
            while start < self.len {
                // Manual pointer access
                auto p = raw[start]
                if !String::is_whitespace(p) {
                    break
                }
                start = start + 1
            }
            
            // Find end
            while end >= start {
                auto p = raw[end]
                if !String::is_whitespace(p) {
                    break
                }
                end = end - 1
            }
            
            auto new_len = end - start + 1
            if new_len <= 0 {
                return String::from("")
            }
            
            auto *sub_start = *raw[start]
            return String::from_with_len(*sub_start, new_len)
        }
    }
    
    // === Extended Utilities (Python-like) ===

    pub fn is_empty(self) -> bool {
        return self.len == 0
    }

    pub fn substring(self, start: i32, end: i32) -> String {
        unsafe {
            auto s# = start
            auto e# = end
            
            // Handle negative indices
            if s < 0 { s = self.len + s }
            if e < 0 { e = self.len + e }
            
            // Clamp
            if s < 0 { s = 0 }
            if s > self.len { s = self.len }
            if e < 0 { e = 0 }
            if e > self.len { e = self.len }
            
            if s >= e {
                return String::from("")
            }
            
            auto new_len = e - s
            auto *start_ptr = (self.c_str() as usize + s as usize) as *char
            return String::from_with_len(*start_ptr, new_len)
        }
    }

    pub fn trim_start(self) -> String {
        unsafe {
            auto start# = 0
            auto *raw = self.c_str()
            while start < self.len {
                if !String::is_whitespace(raw[start]) { break }
                start = start + 1
            }
            
            if start >= self.len { return String::from("") }
            
            auto new_len = self.len - start
            auto *p = (self.c_str() as usize + start as usize) as *char
            return String::from_with_len(*p, new_len)
        }
    }

    pub fn trim_end(self) -> String {
        unsafe {
            auto end# = self.len - 1
            auto *raw = self.c_str()
            while end >= 0 {
                if !String::is_whitespace(raw[end]) { break }
                end = end - 1
            }
            
            auto new_len = end + 1
            if new_len <= 0 { return String::from("") }
            
            return String::from_with_len(*raw, new_len)
        }
    }

    // delim as i32 to avoid ABI char passing issues
    pub fn split(self, delim: i32) -> SplitIterator {
        return SplitIterator(
            *source = self.c_str(),
            source_len = self.len,
            current_pos = 0,
            delimiter = delim as char
        )
    }

    // === New Utilities ===

    pub fn at(self, index: i32) -> char {
        if index < 0 || index >= self.len {
            return 0 as char
        }
        unsafe {
            auto *b = self.c_str()
            return b[index]
        }
    }

    pub fn find_char(self, c: char) -> i32 {
        unsafe {
            auto i# = 0
            auto *b = self.c_str()
            while i < self.len {
                if b[i] == c {
                    return i
                }
                i = i + 1
            }
            return -1
        }
    }

    pub fn starts_with(self, other: String) -> bool {
        if other.len() > self.len { return false }
        unsafe {
            auto i# = 0
            auto *s1 = self.c_str()
            auto *s2 = other.c_str()
            while i < other.len() {
                if s1[i] != s2[i] { return false }
                i = i + 1
            }
            return true
        }
    }

    pub fn ends_with(self, other: String) -> bool {
        if other.len() > self.len { return false }
        unsafe {
            auto i# = 0
            auto *s1 = self.c_str()
            auto *s2 = other.c_str()
            auto offset = self.len - other.len()
            while i < other.len() {
                if s1[offset + i] != s2[i] { return false }
                i = i + 1
            }
            return true
        }
    }

    pub fn contains(self, other: String) -> bool {
        if other.len() == 0 { return true }
        if other.len() > self.len { return false }
        unsafe {
            auto *res = libc_strstr(self.c_str(), other.c_str())
            return *res != (0 as *char)
        }
    }

    pub fn to_upper(self) -> String {
        auto res# = String::from_with_len(self.c_str(), self.len)
        unsafe {
            auto i# = 0
            auto *b# = (res.c_str() as usize) as *char
            while i < res.len {
                auto c = b[i]
                if c >= 97:char && c <= 122:char { // 'a'-'z'
                    b[i] = (c as i32 - 32) as char
                }
                i = i + 1
            }
        }
        return res
    }

    pub fn to_lower(self) -> String {
        auto res# = String::from_with_len(self.c_str(), self.len)
        unsafe {
            auto i# = 0
            auto *b# = (res.c_str() as usize) as *char
            while i < res.len {
                auto c = b[i]
                if c >= 65:char && c <= 90:char { // 'A'-'Z'
                    b[i] = (c as i32 + 32) as char
                }
                i = i + 1
            }
        }
        return res
    }

    pub fn replace(self, old_c: char, new_c: char) -> String {
        auto res# = String::from_with_len(self.c_str(), self.len)
        unsafe {
            auto i# = 0
            auto *b# = (res.c_str() as usize) as *char
            while i < res.len {
                if b[i] == old_c {
                    b[i] = new_c
                }
                i = i + 1
            }
        }
        return res
    }

    pub fn find_str(self, needle: String) -> i32 {
        unsafe {
            if needle.len() == 0 { return 0 }
            auto *res = libc_strstr(self.c_str(), needle.c_str())
            if *res == (0 as *char) { return -1 }
            auto offset = (*res as usize) - (self.c_str() as usize)
            return offset as i32
        }
    }

    pub fn replace_str(self, old_s: String, new_s: String) -> String {
        if old_s.len() == 0 { return self.clone() }
        
        auto res# = String::from("")
        unsafe {
             auto i# = 0
             // Get pointers to buffers
             auto *s_buf = self.c_str()
             auto *old_buf = old_s.c_str()
             
             while i < self.len {
                 auto is_match# = true
                 if i + old_s.len() > self.len {
                     is_match = false
                 } else {
                     auto j# = 0
                     while j < old_s.len() {
                         // Direct buffer access for speed inside unsafe
                         auto idx = i + j
                         if s_buf[idx] != old_buf[j] {
                             is_match = false
                             break
                         }
                         j = j + 1
                     }
                 }
                 
                 if is_match {
                     res#.push_str(new_s.c_str())
                     i = i + old_s.len()
                 } else {
                     res#.push_char(s_buf[i])
                     i = i + 1
                 }
             }
        }
        return res
    }
    
    pub fn repeat(self, n: i32) -> String {
        if n <= 0 { return String::from("") }
        auto res# = String::from("")
        // Pre-reserve could be optimization todo
        auto i# = 0
        while i < n {
            res#.push_str(self.c_str())
            i = i + 1
        }
        return res
    }
    
    pub fn reverse(self) -> String {
        if self.len <= 1 { return self.clone() }
        unsafe {
            auto res# = String::from_with_len(self.c_str(), self.len)
            auto i# = 0
            auto *dest# = (res.c_str() as usize) as *char
            auto *src = self.c_str()
            while i < self.len {
                dest[i] = src[self.len - 1 - i]
                i = i + 1
            }
            return res
        }
    }
}
impl String@Hash {
    pub fn hash(self) -> u64 {
        unsafe {
            auto hash#: u64 = 5381
            auto i# = 0
            auto *b = self.c_str()
            while i < self.len {
                auto c = b[i] as u64
                hash = ((hash bshl 5) + hash) + c
                i = i + 1
            }
            return hash
        }
    }
}
