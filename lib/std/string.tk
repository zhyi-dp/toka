// Copyright (c) 2025 YiZhonghua<zhyi@dpai.com>. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ==========================================
// Toka Standard Library: String
// Version: 1.3.1 (In-Place Capture & Strict Morphology)
// ==========================================

import core/types::{char, usize, Addr, ADDR0}
import core/traits::{@encap}
import core/libc::*


// ------------------------------------------------------
// 2. Shape Definition
// ------------------------------------------------------

pub shape String (
    *buf#: char,
    len: i32,
    cap: i32
)

impl String@encap {
    pub cap
    fn drop(self#) {
        unsafe {
            if self.*buf != nullptr {
                // libc_free(self.*buf as *void)
                self#.*buf = nullptr 
                self#.len = 0
                // self#.cap = 0
            }
        }
    }
}

// ------------------------------------------------------
// 3. Iterators
// ------------------------------------------------------

pub shape SplitIterator (
    *source: char,
    source_len: i32,
    current_pos: i32,
    delimiter: char
)

impl SplitIterator@encap {
    fn drop(self#) {
        // Observer only, no resource to free
    }
}

impl SplitIterator {
    pub fn next(self#) -> String {
        unsafe {
             if self.current_pos >= self.source_len {
                 return String::from("") 
             }
             
             auto start = self.current_pos
             auto found# = false
             auto i# = start
             
             while i < self.source_len {
                 // dereference
                 if self.*source[i] == self.delimiter {
                     found# = true
                     break
                 }
                 i# = i + 1
             }
             
             auto end = i
             auto len = end - start
             
             // Update iterator state
             if found {
                 self#.current_pos = end + 1
             } else {
                 self#.current_pos = self.source_len + 1 // Done
             }
             
             // Extract substring
             auto *start_ptr = self.*source + start
             return String::from_with_len(*start_ptr, len)
        }
    }
    
    pub fn is_done(self) -> bool {
        return self.current_pos > self.source_len
    }
}


// ------------------------------------------------------
// 4. String Implementation
// ------------------------------------------------------

impl String {

    // === Constructors ===

    pub fn from(*s: char) -> String {
        unsafe {
            auto l = libc_strlen(*s)
            auto *p# = libc_malloc((l + 1) as usize) as *char
            libc_memcpy(*p as *void, *s as *void, l)
            p#[l] = 0 as char
            
            return String(
                *buf = *p,
                len = l as i32,
                cap = (l + 1) as i32
            )
        }
    }
    
    // Internal helper for substrings
    pub fn from_with_len(*s: char, len: i32) -> String {
        unsafe {
            auto l = len
            auto *p# = libc_malloc((l + 1) as usize) as *char
            libc_memcpy(*p as *void, *s as *void, l as usize)
            p#[l] = 0 as char
            
            return String(
                *buf = *p,
                len = l,
                cap = l + 1
            )
        }
    }

    // === Converters ===

    /**
     * Creates a String from a C-string and frees the input pointer.
     * Useful for FFI functions returning allocated strings.
     */
    pub fn from_take(*s: char) -> String {
        unsafe {
            libc_write(2, "DEBUG: from_take entry\n" as *u8, 23)
            auto l = libc_strlen(*s)
            
            libc_write(2, "DEBUG: from_take strlen done\n" as *u8, 29)
            
            auto *p# = libc_malloc((l + 1) as usize) as *char
            libc_memcpy(*p as *void, *s as *void, l)
            p#[l] = 0 as char
            
            // Free the input pointer (take ownership)
            // libc_free(*s as *void)
            
            libc_write(2, "DEBUG: from_take free skipped\n" as *u8, 30)
            
            return String(
                *buf = *p,
                len = l as i32,
                cap = (l + 1) as i32
            )
        }
    }

    pub fn clone(self) -> String {
        return String::from_with_len(self.c_str(), self.len)
    }

    pub fn from_int(val: i32) -> String {
        unsafe {
            // Max i32 chars is 11 (-2147483648) + null
            auto *buf# = libc_malloc(16) as *char
            libc_sprintf(*buf, "%d", val)
            auto len = libc_strlen(*buf)
            
            return String(
                *buf = *buf,
                len = len as i32,
                cap = 16
            )
        }
    }

    pub fn from_i64(val: i64) -> String {
        unsafe {
            auto *buf# = libc_malloc(32) as *char
            libc_sprintf(*buf, "%lld", val)
            auto len = libc_strlen(*buf)
            return String(*buf = *buf, len = len as i32, cap = 32)
        }
    }
    
    pub fn from_f64(val: f64) -> String {
         unsafe {
            auto *buf# = libc_malloc(32) as *char
            libc_sprintf(*buf, "%.6f", val)
            auto len = libc_strlen(*buf)
            return String(*buf = *buf, len = len as i32, cap = 32)
        }
    }

    // === View ===
    
    pub fn len(self) -> i32 {
        return self.len
    }

    pub fn capacity(self) -> i32 {
        return self.cap
    }

    pub fn c_str(self) -> *char {
        return self.*buf as *char
    }
    
    // === Mutation ===

    pub fn push_str(self#, *s: char) -> i32 {
        unsafe {
            auto slen = libc_strlen(*s)
            auto needed = self.len + (slen as i32)
            
            if needed >= self.cap {
                auto new_cap = (self.cap * 2) + (slen as i32) + 1
                auto *tmp = libc_realloc(self.*buf as *void, new_cap as usize) as *char
                if *tmp == (0 as *char) { return 0 }
                self#.*buf = *tmp
                self#.cap = new_cap
            }
            
            auto *dst# = (self.*buf as usize + self.len as usize) as *char
            libc_memcpy(*dst as *void, *s as *void, slen)
            self#.len = needed
            dst#[slen] = 0 as char
        }
        return 1
    }

    pub fn push_char(self#, c: char) -> i32 {
        unsafe {
            auto needed = self.len + 1
            
            if needed >= self.cap {
                auto new_cap = (self.cap * 2) + 2
                auto *tmp = libc_realloc(self.*buf as *void, new_cap as usize) as *char
                if *tmp == (0 as *char) { return 0 }
                self#.*buf = *tmp
                self#.cap = new_cap
            }
            
            auto *dst# = (self.*buf as usize + self.len as usize) as *char
            dst#[0] = c
            dst#[1] = 0 as char
            self#.len = needed
        }
        return 1
    }

    pub fn eq(self, other: String) -> bool {
        unsafe {
            if self.len != other.len() { return false }
            auto i# = 0
            auto *b1 = self.c_str()
            auto *b2 = other.c_str()
            while i < self.len {
                auto *p1 = (b1 as usize + i as usize) as *char
                auto *p2 = (b2 as usize + i as usize) as *char
                if *p1 != *p2 { return false }
                i# = i + 1
            }
            return true
        }
    }

    pub fn clear(self#) {
        self#.drop()
    }
    
    // === Utilities ===
    
    fn is_whitespace(c: char) -> bool {
        if c == 32 as char { return true } // space
        if c == 9 as char { return true }  // tab
        if c == 10 as char { return true } // newline
        if c == 13 as char { return true } // cr
        return false
    }

    pub fn trim(self) -> String {
        unsafe {
            auto start# = 0
            auto end# = self.len - 1
            auto *raw = self.c_str()
            
            // Find start
            while start < self.len {
                // Manual pointer access
                auto p = raw[start]
                if !String::is_whitespace(p) {
                    break
                }
                start# = start + 1
            }
            
            // Find end
            while end >= start {
                auto p = raw[end]
                if !String::is_whitespace(p) {
                    break
                }
                end# = end - 1
            }
            
            auto new_len = end - start + 1
            if new_len <= 0 {
                return String::from("")
            }
            
            auto *sub_start = *raw[start]
            return String::from_with_len(*sub_start, new_len)
        }
    }
    
    // delim as i32 to avoid ABI char passing issues
    pub fn split(self, delim: i32) -> SplitIterator {
        return SplitIterator(
            *source = self.c_str(),
            source_len = self.len,
            current_pos = 0,
            delimiter = delim as char
        )
    }

    // === New Utilities ===

    pub fn at(self, index: i32) -> char {
        if index < 0 || index >= self.len {
            return 0 as char
        }
        unsafe {
            return self.*buf[index]
        }
    }

    pub fn find_char(self, c: char) -> i32 {
        unsafe {
            auto i# = 0
            while i < self.len {
                if self.*buf[i] == c {
                    return i
                }
                i# = i + 1
            }
            return -1
        }
    }

    pub fn starts_with(self, other: String) -> bool {
        if other.len() > self.len { return false }
        unsafe {
            auto i# = 0
            auto *s1 = self.c_str()
            auto *s2 = other.c_str()
            while i < other.len() {
                if s1[i] != s2[i] { return false }
                i# = i + 1
            }
            return true
        }
    }

    pub fn ends_with(self, other: String) -> bool {
        if other.len() > self.len { return false }
        unsafe {
            auto i# = 0
            auto *s1 = self.c_str()
            auto *s2 = other.c_str()
            auto offset = self.len - other.len()
            while i < other.len() {
                if s1[offset + i] != s2[i] { return false }
                i# = i + 1
            }
            return true
        }
    }

    pub fn contains(self, other: String) -> bool {
        if other.len() == 0 { return true }
        if other.len() > self.len { return false }
        unsafe {
            auto *res = libc_strstr(self.c_str(), other.c_str())
            return *res != (0 as *char)
        }
    }

    pub fn to_upper(self) -> String {
        auto res# = String::from_with_len(self.c_str(), self.len)
        unsafe {
            auto i# = 0
            while i < res.len {
                auto c = res.*buf[i]
                if c >= 97:char && c <= 122:char { // 'a'-'z'
                    res#.*buf[i] = (c as i32 - 32) as char
                }
                i# = i + 1
            }
        }
        return res
    }

    pub fn to_lower(self) -> String {
        auto res# = String::from_with_len(self.c_str(), self.len)
        unsafe {
            auto i# = 0
            while i < res.len {
                auto c = res.*buf[i]
                if c >= 65:char && c <= 90:char { // 'A'-'Z'
                    res#.*buf[i] = (c as i32 + 32) as char
                }
                i# = i + 1
            }
        }
        return res
    }

    pub fn replace_char(self, old_c: char, new_c: char) -> String {
        auto res# = String::from_with_len(self.c_str(), self.len)
        unsafe {
            auto i# = 0
            while i < res.len {
                if res.*buf[i] == old_c {
                    res#.*buf[i] = new_c
                }
                i# = i + 1
            }
        }
        return res
    }
}