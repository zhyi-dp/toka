// Copyright (c) 2025 YiZhonghua<zhyi@dpai.com>. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import core/types::{usize, Addr, ADDR0}
import core/traits::{@encap}
import core/libc::*
import std/io::println

// Helper for mutable iteration
shape Counter(val: usize)
impl Counter {
    fn inc(self#) {
        self.val += 1
    }
}

// Module-level factory functions removed. using static methods.

pub shape Vec<T> (
    *!buf#: T,
    len: usize,
    cap: usize
)

impl<T> Vec<T>@encap {
    fn drop(self#) {
        println("drop Vec<T>")
        unsafe {
            if self.*buf != nullptr {
                unsafe free [self.cap]self.*#buf
                self.*buf = nullptr // Explicit nullify
              
            }
        }
    }
}

impl<T> Vec<T> {
    // Getters for length and capacity
    pub fn len(self) -> usize {
        return self.len
    }

    pub fn cap(self) -> usize {
        return self.cap
    }
    
    // Create empty vector (Static Method)
    pub fn new() -> Vec<T> {
        // Implicit conversation works for assignment/init of pointer variable
        return Vec<T>(*!buf=nullptr, len=0, cap=0)
    }

    // Create vector with capacity (Static Method)
    pub fn with_capacity(capacity: usize) -> Vec<T> {
        unsafe {
            if capacity == 0 {
                return Vec<T>(*!buf=nullptr, len=0, cap=0)
            }
            // alloc array syntax
            auto *new_buf# = unsafe alloc [capacity] T
            return Vec<T>(*buf=*new_buf, len=0, cap=capacity)
        }
    }

    // Push element to end
    pub fn push(self#, val: T) {
        unsafe {
            if self.len == self.cap {
                self.grow()
            }
            
            // Pointer indexing handles
            // *self.buf provides the handle.
            self.buf[self.len] = val
            self.len += 1
        }
    }
    
    // Pop element from end
    pub fn pop(self#) -> T {
        unsafe {
            if self.len == 0 {
                libc_printf("Error: pop from empty Vec\n")
                libc_exit(1)
            }
            
            self.len -= 1
            return self.buf[self.len]
        }
    }
    
    // Get element at index
    pub fn get(self, index: usize) -> T {
        unsafe {
             if index >= self.len {
                 libc_printf("Error: index out of bounds\n")
                 libc_exit(1)
             }
             return self.buf[index]
        }
    }

    // Helper: Grow buffer
    fn grow(self#) {
        println("grow, old cap: {}", self.cap)
        unsafe {
            // Determine new capacity
            auto new_cap = self.cap * 2
            
            if new_cap == 0 {
                // Initial allocation case
                auto cap = 4 : usize
                auto *new_buf# = unsafe alloc [4]T
                
                // Fields
                self.*buf = *new_buf
                self.cap = cap
            } else {
                // Growth case
                auto *new_buf# = unsafe alloc [new_cap]T
                
                // Copy elements manually
                auto ctr# = Counter(val=0)
                while ctr.val < self.len {
                    new_buf[ctr.val] = self.buf[ctr.val]
                    ctr.inc()
                }
                
                // Free old buffer
                if self.*buf != nullptr {
                    unsafe free [self.cap]self.*#buf
                }
                
                // Update fields
                self.*buf = *new_buf
                self.cap = new_cap
            }
        }
    }
}
