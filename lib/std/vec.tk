// Copyright (c) 2025 YiZhonghua<zhyi@dpai.com>. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import core/types::{usize, Addr, ADDR0}
import core/traits::{@encap}
import core/libc::*
import std/io::println
import core/option::{Option}


// Helper for mutable iteration
shape Counter(val: usize)
impl Counter {
    fn inc(self#) {
        self.val += 1
    }
}

// Module-level factory functions removed. using static methods.

pub shape Vec<T> (
    *?buf#: T,
    len: usize,
    cap: usize
)

impl<T> Vec<T>@encap {
    fn drop(self#) {
        unsafe {
            if self.*buf != nullptr {
                unsafe free [self.cap]self.*#buf
                self.*buf = nullptr // Explicit nullify
              
            }
        }
    }

    fn clone(self) -> Vec<T> {
        // Deep clone of the vector structure
        // Note: Elements are copied via assignment. 
        // Once compiler supports auto-clone on assign, this becomes deep copy for elements too.
        unsafe {
            if self.cap == 0 {
                // Avoid calling new() to prevent circular instantiation loop in compiler
                return Vec<T>(*!buf=nullptr, len=0, cap=0)
            }
            // alloc array
            auto *new_buf# = unsafe alloc [self.cap] T
            
            // Copy elements
            auto ctr# = Counter(val=0)
            while ctr.val < self.len {
                new_buf[ctr.val] = self.buf[ctr.val]
                ctr#.inc()
            }
            
            return Vec<T>(*buf=*new_buf, len=self.len, cap=self.cap)
        }
    }
}

impl<T> Vec<T> {
    // Getters for length and capacity
    pub fn len(self) -> usize {
        return self.len
    }

    pub fn cap(self) -> usize {
        return self.cap
    }
    
    // Create empty vector (Static Method)
    pub fn new() -> Vec<T> {
        // Implicit conversation works for assignment/init of pointer variable
        return Vec<T>(*!buf=nullptr, len=0, cap=0)
    }

    // Create vector with capacity (Static Method)
    pub fn with_capacity(capacity: usize) -> Vec<T> {
        unsafe {
            if capacity == 0 {
                return Vec<T>(*!buf=nullptr, len=0, cap=0)
            }
            // alloc array syntax
            auto *new_buf# = unsafe alloc [capacity] T
            return Vec<T>(*buf=*new_buf, len=0, cap=capacity)
        }
    }

    // Push element to end
    pub fn push(self#, val: T) {
        unsafe {
            if self.len == self.cap {
                self#.grow()
            }
            
            // Pointer indexing handles
            // *self.buf provides the handle.
            self.buf[self.len] = val
            self.len += 1
        }
    }
    
    // Pop element from end
    pub fn pop(self#) -> Option<T> {
        unsafe {
            if self.len == 0 {
                return Option<T>::None
            }
            
            self.len -= 1
            // Copy out
            auto val = self.buf[self.len]
            return Option<T>::Some(val)
        }
    }
    
    // Get element at index (Returns Copy/Move)
    pub fn get(self, index: usize) -> T {
        unsafe {
             if index >= self.len {
                 libc_exit(1)
             }
             auto val = self.buf[index]
             return val
        }
    }
    
    // Alias to get
    pub fn at(self, index: usize) -> T {
        return self.get(index)
    }

    // Unsafe Reference Get (Returns Pointer/Handle)
    // Used to peek without copying/moving.
    pub fn get_ref(self, index: usize) -> *T {
        unsafe {
             if index >= self.len {
                 return nullptr
             }
             return *self.buf[index]
        }
    }

    // Safe get
    pub fn get_opt(self, index: usize) -> Option<T> {
        unsafe {
             if index >= self.len {
                 return Option<T>::None
             }
             auto val = self.buf[index]
             return Option<T>::Some(val)
        }
    }

    pub fn unsafe_get(self, index: usize) -> *T {
        unsafe {
            if self.*buf != nullptr {
                // 这一步显式转换： *?T -> *T
                // 既然已经判空，这就是安全的 unsafe 操作
                auto *ptr = self.*buf as *T
                return *ptr[index]
            }
            return nullptr
        }
    }

    pub fn unsafe_forget(self#) {
        unsafe {
            // Nullify buffer to prevent drop from freeing it
            // This is used when ownership is manually transferred
            self.*buf = nullptr
            self.cap = 0
            self.len = 0
        }
    }

    // Helper: Grow buffer
    fn grow(self#) {
        unsafe {
            // Determine new capacity
            auto new_cap = self.cap * 2
            
            if new_cap == 0 {
                // Initial allocation case
                auto cap = 4 : usize
                auto *new_buf# = unsafe alloc [4]T
                
                // Fields
                self.*buf = *new_buf
                self.cap = cap
            } else {
                // Growth case
                auto *new_buf# = unsafe alloc [new_cap]T
                
                // Copy elements manually
                auto ctr# = Counter(val=0)
                while ctr.val < self.len {
                    new_buf[ctr.val] = self.buf[ctr.val]
                    ctr#.inc()
                }
                
                // Free old buffer
                if self.*buf != nullptr {
                    unsafe free [self.cap]self.*#buf
                }
                
                // Update fields
                self.*buf = *new_buf
                self.cap = new_cap
            }
        }
    }

    // Resize vector (fill with value)
    pub fn resize(self#, new_len: usize, val: T) {
        unsafe {
            if new_len > self.cap {
                 while self.cap < new_len {
                     self#.grow()
                 }
            }
            // Fill from old_len to new_len
            auto i# = self.len
            while i < new_len {
                self.buf[i] = val
                i += 1
            }
            self.len = new_len
        }
    }

    // Set value at index
    pub fn set(self#, index: usize, val: T) {
        unsafe {
             if index < self.len {
                 self.buf[index] = val
             }
        }
    }

    // Create Iterator
    pub fn iter(self) -> VecIterator<T> {
        unsafe {
            return VecIterator<T>(
                *buf = self.*buf,
                len = self.len,
                pos = 0
            )
        }
    }
}

pub shape VecIterator<T> (
    *!buf : T,
    len : usize,
    pos# : usize
)

impl<T> VecIterator<T>@encap {
    fn drop(self#) {}
    fn clone(self) -> VecIterator<T> {
        return VecIterator<T>(
             *buf = self.*buf,
             len = self.len,
             pos = self.pos
        )
    }
}

// Concrete Implementation
impl<T> VecIterator<T> {
    pub fn next(self) -> Option<T> {
        unsafe {
            if self.pos >= self.len {
                return Option<T>::None
            }
            
            auto val = self.buf[self.pos]
            self.pos += 1
            return Option<T>::Some(val)
        }
    }
}
