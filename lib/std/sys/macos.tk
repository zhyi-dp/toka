// Copyright (c) 2025 YiZhonghua<zhyi@dpai.com>. All rights reserved.
import core/types::{char, usize, Addr, ADDR0}
import std/string::{String}
import core/libc::*

// macOS specific argument retrieval externs.
extern fn _NSGetArgc() -> *i32
extern fn _NSGetArgv() -> *Addr 

// Returns the number of command-line arguments.
pub fn args_impl() -> i32 {
    unsafe {
        auto *argc = _NSGetArgc()
        return argc[0]
    }
}

// Retrieves a specific command-line argument by index.
pub fn get_arg_impl(i: i32) -> String {
    unsafe {
        auto *handle_ptr = _NSGetArgv()
        auto handle_addr = handle_ptr[0] as Addr
        auto *p_argv_base = handle_addr as *Addr
        auto argv_array_base = p_argv_base[0] as Addr
        
        auto slot_addr = (argv_array_base as u64 + (i as u64) * 8) as Addr
        auto *p_str = slot_addr as *Addr
        auto str_addr = p_str[0] as Addr
        auto *final_ptr = str_addr as *char
        
        return String::from(final_ptr)
    }
}

// === File System ===

pub fn opendir_impl(path: String) -> Addr {
    unsafe {
        return libc_opendir(path.c_str())
    }
}

pub fn readdir_impl(dir_handle: Addr) -> String {
    unsafe {
        auto entry = libc_readdir(dir_handle as Addr) // returns Addr
        if entry == ADDR0 {
            return String::from("") 
        }
        
        // Calculate offset to d_name (offset 21)
        // d_name is at offset 21
        auto *name_ptr = ((entry as u64 + 21) as Addr) as *char
        
        return String::from(name_ptr)
    }
}

pub fn closedir_impl(dir_handle: Addr) {
    unsafe {
        libc_closedir(dir_handle as Addr)
    }
}

pub fn mkdir_impl(path: String) -> bool {
    unsafe {
        // 0755 = 493 in decimal
        return libc_mkdir(path.c_str(), 493) == 0
    }
}

pub fn rmdir_impl(path: String) -> bool {
    unsafe {
        return libc_rmdir(path.c_str()) == 0
    }
}

pub fn path_exists(path: String) -> bool {
    unsafe {
        // Use access(path, F_OK=0)
        return libc_access(path.c_str(), 0) == 0
    }
}

// === Environment ===

pub fn getcwd_impl() -> String {
    unsafe {
        // Real implementation using getcwd
        auto *buf = libc_malloc(1024) as *char
        auto res_addr = libc_getcwd(*buf, 1024:usize)
        if res_addr == ADDR0 {
             libc_free(*buf as *void)
             return String::from("")
        }
        return String::from_take(*buf)
    }
}

pub fn chdir_impl(path: String) -> bool {
    unsafe {
        return libc_chdir(path.c_str()) == 0
    }
}

pub fn getenv_impl(name: String) -> String {
    unsafe {
        // libc_getenv returns *char (Borrowed)
        auto *val = libc_getenv(name.c_str())
        
        if *val == nullptr {
            return String::from("")
        }
        
        // Copy from borrowed pointer
        return String::from(*val)
    }
}

pub fn setenv_impl(name: String, value: String) -> bool {
    unsafe {
        // overwrite = 1
        return libc_setenv(name.c_str(), value.c_str(), 1) == 0
    }
}

pub fn unsetenv_impl(name: String) -> bool {
    unsafe {
        return libc_unsetenv(name.c_str()) == 0
    }
}

pub fn __toka_panic_handler(msg: str) {
    // macOS 特有的实现：写 stderr + 退出
    libc_abort()
}

// === Networking ===

// Constants for macOS
// AF_INET = 2
// SOCK_STREAM = 1
// SOL_SOCKET = 0xffff (65535)
// SO_REUSEADDR = 0x0004

extern fn __error() -> *i32

pub fn get_last_error() -> i32 {
    unsafe {
        auto *ptr = __error()
        return ptr
    }
}

pub fn net_socket_impl() -> i32 {
    unsafe {
        return libc_socket(2, 1, 0)
    }
}

pub fn net_setsockopt_reuse_impl(fd: i32) -> i32 {
    unsafe {
        auto *opt# = libc_malloc(4) as *i32
        opt[0] = 1
        auto res = libc_setsockopt(fd, 65535, 4, *opt as *void, 4)
        libc_free(*opt as *void)
        return res
    }
}

// Helper to fill sockaddr_in (IPv4)
// dest must be a pointer to at least 16 bytes.
// Toka: *addr_buf: char declares addr_buf as *char
// Helper to fill sockaddr_in (IPv4)
// dest must be a pointer to at least 16 bytes.
// Toka: *addr_buf: char declares addr_buf as *char
// Helper to fill sockaddr_in (IPv4)
// dest must be a pointer to at least 16 bytes.
// Toka: *addr_buf: char declares addr_buf as *char (Handle is *addr_buf, Value is addr_buf)
// Helper to fill sockaddr_in (IPv4)
// dest must be a pointer to at least 16 bytes.
// Toka: *addr_buf: char declares addr_buf as *char (Handle is *addr_buf, Value is addr_buf)
fn fill_sockaddr_in(*addr_buf: char, ip: usize, port: i32) -> bool {
    // Capture handle safely outside unsafe block? No, access to handle is permitted.
    // We use unsafe block for pointer arithmetic and raw writes.
    unsafe {
        // addr_buf (no hat) would be the char value (read from memory).
        // *addr_buf (with hat) is the pointer handle.
        
        // Copy the handle to a local variable for arithmetic
        // Mark as mutable (#) so we can write to the memory it points to (rebind value)
        auto *base_ptr# = *addr_buf
        
        // Offset 0: len = 16
        // Write to memory at base_ptr. 
        // In Toka, 'base_ptr' (no hat) refers to the pointed value (memory).
        // So assignment writes to memory.
        base_ptr = 16 as char
        
        // Offset 1: family = 2
        // Arithmetic on handle (*base_ptr)
        // Cast to usize, add 1, cast back to *char
        auto *p1# = (*base_ptr as usize + 1) as *char
        p1 = 2 as char
        
        // Offset 2: port (u16)
        auto nport: u16 = libc_htons(port as u16)
        auto *p_port# = (*base_ptr as usize + 2) as *u16
        p_port = nport
        
        // Offset 4: addr (u32, via inet_pton)
        auto *p_addr = (*base_ptr as usize + 4) as *void
        // Pass HANDLE (*p_addr) to external function
        auto *ip_ptr# = ip as *char
        auto res = libc_inet_pton(2, *ip_ptr, *p_addr)
        
        if res != 1 {
             return false
        }
        
        // Offset 8..16: Zero
        auto i# = 8
        while i < 16 {
            auto *p_z# = (*base_ptr as usize + i) as *char
            p_z = 0 as char
            i += 1
        }
        return true
    }
}

// Redeclare syscalls to ensure correct pointer sizes (avoiding libc.tk potential issues)
extern fn bind(fd: i32, *addr: void, len: u32) -> i32
extern fn connect(fd: i32, *addr: void, len: u32) -> i32
extern fn accept(fd: i32, *addr: void, *len: u32) -> i32
extern fn listen(fd: i32, backlog: i32) -> i32
extern fn setsockopt(fd: i32, level: i32, optname: i32, *optval: void, optlen: u32) -> i32

pub fn net_bind_impl(fd: i32, host: usize, port: i32) -> i32 {
    unsafe {
        // Allocate 32 bytes to be safe
        auto *addr_buf# = libc_malloc(32) as *char
        
        if *addr_buf as usize == 0 {
             return -1
        }
        
        if !fill_sockaddr_in(*addr_buf, host, port) {
            libc_free(*addr_buf as *void)
            return -1
        }
        
        // Use bind
        auto res = bind(fd, *addr_buf as *void, 16)
        libc_free(*addr_buf as *void)
        return res
    }
}

pub fn net_listen_impl(fd: i32) -> i32 {
    unsafe {
        // Backlog 128
        return libc_listen(fd, 128)
    }
}

pub fn net_connect_impl(fd: i32, host: usize, port: i32) -> i32 {
    unsafe {
        auto *addr_buf# = libc_malloc(32) as *char
        
        if *addr_buf as usize == 0 {
             return -2
        }

        if !fill_sockaddr_in(*addr_buf, host, port) {
            libc_free(*addr_buf as *void)
            return -3
        }
        
        // Use connect with correct handle
        auto res = connect(fd, *addr_buf as *void, 16)
        libc_free(*addr_buf as *void)
        return res
    }
}

pub fn net_accept_impl(fd: i32) -> i32 {
    unsafe {
        // We ignore the peer address for now in this impl
        auto *addr_len_ptr# = libc_malloc(4) as *u32
        addr_len_ptr[0] = 16
        auto *addr_buf# = libc_malloc(16) as *void
        
        auto res = libc_accept(fd, *addr_buf, *addr_len_ptr)
        
        libc_free(*addr_len_ptr as *void)
        libc_free(*addr_buf)
        return res
    }
}

pub fn net_close_impl(fd: i32) {
    unsafe {
        libc_close(fd)
    }
}

pub fn net_read_impl(fd: i32, *buf: u8, len: usize) -> i64 {
    unsafe {
        // Pass *buf (pointer) to libc_read
        return libc_read(fd, *buf, len as i64)
    }
}

pub fn net_write_impl(fd: i32, *buf: u8, len: usize) -> i64 {
    unsafe {
        // Pass *buf (pointer) to libc_write
        return libc_write(fd, *buf, len as i64)
    }
}