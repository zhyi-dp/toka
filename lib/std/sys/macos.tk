// Copyright (c) 2025 YiZhonghua<zhyi@dpai.com>. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import core/types::{char, usize, Addr, ADDR0}
import std/string::{String}
import core/libc::*

// macOS specific argument retrieval externs.
extern fn _NSGetArgc() -> *i32
extern fn _NSGetArgv() -> *Addr 

// Returns the number of command-line arguments.
pub fn args_impl() -> i32 {
    unsafe {
        auto *argc = _NSGetArgc()
        return argc[0]
    }
}

// Retrieves a specific command-line argument by index.
pub fn get_arg_impl(i: i32) -> String {
    unsafe {
        auto *handle_ptr = _NSGetArgv()
        auto handle_addr = handle_ptr[0] as Addr
        auto *p_argv_base = handle_addr as *Addr
        auto argv_array_base = p_argv_base[0] as Addr
        
        auto slot_addr = (argv_array_base as u64 + (i as u64) * 8) as Addr
        auto *p_str = slot_addr as *Addr
        auto str_addr = p_str[0] as Addr
        auto *final_ptr = str_addr as *char
        
        return String::from(final_ptr)
    }
}

// === File System ===

// struct dirent layout on macOS (inode64):
// u64 d_ino      (0-8)
// u64 d_seekoff  (8-16)
// u16 d_reclen   (16-18)
// u16 d_namlen   (18-20)
// u8  d_type     (20-21)
// char d_name[]  (21-...)

pub fn opendir_impl(path: String) -> Addr {
    unsafe {
        return libc_opendir(path.c_str())
    }
}

pub fn readdir_impl(dir_handle: Addr) -> String {
    unsafe {
        auto entry = libc_readdir(dir_handle as Addr) // returns Addr
        if entry == ADDR0 {
            return String::from("") 
        }
        
        // Calculate offset to d_name (offset 21)
        // d_name is at offset 21
        auto *name_ptr = ((entry as u64 + 21) as Addr) as *char
        
        return String::from(name_ptr)
    }
}

pub fn closedir_impl(dir_handle: Addr) {
    unsafe {
        libc_closedir(dir_handle as Addr)
    }
}

pub fn mkdir_impl(path: String) -> bool {
    unsafe {
        // 0755 = 493 in decimal
        return libc_mkdir(path.c_str(), 493) == 0
    }
}

pub fn rmdir_impl(path: String) -> bool {
    unsafe {
        return libc_rmdir(path.c_str()) == 0
    }
}

pub fn path_exists(path: String) -> bool {
    unsafe {
        // Use access(path, F_OK=0)
        return libc_access(path.c_str(), 0) == 0
    }
}

// === Environment ===

pub fn getcwd_impl() -> String {
    unsafe {
        // libc_write(2, "DEBUG: getcwd_impl returning dummy\n" as *u8, 31)
        // return String::from("test_cwd_dummy")
        
        // Real implementation using getcwd
        auto *buf = libc_malloc(1024) as *char
        auto res_addr = libc_getcwd(*buf, 1024:usize)
        if res_addr == ADDR0 {
             libc_free(*buf as *void)
             return String::from("")
        }
        return String::from_take(*buf)
    }
}

pub fn chdir_impl(path: String) -> bool {
    unsafe {
        return libc_chdir(path.c_str()) == 0
    }
}

pub fn getenv_impl(name: String) -> String {
    unsafe {
        // libc_getenv returns *char (Borrowed)
        auto *val = libc_getenv(name.c_str())
        
        if *val == nullptr {
            return String::from("")
        }
        
        // Copy from borrowed pointer
        return String::from(*val)
    }
}

pub fn setenv_impl(name: String, value: String) -> bool {
    unsafe {
        // overwrite = 1
        return libc_setenv(name.c_str(), value.c_str(), 1) == 0
    }
}

pub fn unsetenv_impl(name: String) -> bool {
    unsafe {
        return libc_unsetenv(name.c_str()) == 0
    }
}

pub fn __toka_panic_handler(msg: str) {
    // macOS 特有的实现：写 stderr + 退出
    libc_abort()
}