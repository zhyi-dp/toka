import core/types::{char, usize, Addr}
import std/string::{String}

// macOS specific argument retrieval externs.
// _NSGetArgc returns a pointer (*i32) to the integer count of arguments.
extern fn _NSGetArgc() -> *i32

// _NSGetArgv returns a pointer to the global 'argv' variable.
// Because Toka does not support triple pointers (***char), we treat the
// 'argv' variable as a memory slot containing an Addr (the array base).
extern fn _NSGetArgv() -> *Addr 

/**
 * Returns the number of command-line arguments.
 * In Toka, naming a pointer variable without the '*' prefix (argc) 
 * automatically accesses the 'Soul' (the dereferenced value).
 */
pub fn args() -> i32 {
    unsafe {
        auto *argc = _NSGetArgc()
        return argc // 'argc' refers to the i32 value pointed to by *argc.
    }
}

/**
 * Retrieves a specific command-line argument by index.
 * Demonstrates the 'Flattened Physical Sovereignty' model of Toka.
 */
pub fn get_arg(i: i32) -> String {
    unsafe {
        // STEP 1: Get the handle to the 'argv' variable.
        // *handle_ptr represents the Identity (the pointer to the argv variable).
        auto *handle_ptr = _NSGetArgv()
        
        // STEP 2: Extract the physical address of the argv variable.
        // We cast the Identity (*handle_ptr) to a raw Addr to strip pointer semantics.
        auto handle_addr = *handle_ptr as Addr
        
        // STEP 3: Establish sovereignty over the argv variable slot.
        // We create a pointer *p_argv_base that points to the argv variable.
        auto *p_argv_base = handle_addr as *Addr
        
        // STEP 4: Extract the 'Soul' of p_argv_base.
        // Using the name 'p_argv_base' without '*' gives us the value stored 
        // in the variable (which is the base address of the argv array).
        // We cast to Addr to ensure flat mathematical operations later.
        auto argv_array_base = p_argv_base as Addr
        
        // STEP 5: Calculate the physical address of the i-th slot.
        // Every pointer in the array occupies 8 bytes (pointer size).
        // We use flat Addr math to avoid implicit compiler pointer scaling.
        auto slot_addr = argv_array_base + i * 8
            
        // STEP 6: Establish sovereignty over the specific array slot.
        // We treat the calculated slot_addr as a pointer to an Addr.
        auto *p_str = slot_addr as *Addr
        
        // STEP 7: Extract the string's starting address (the Soul of the slot).
        // This gives us the raw memory address where the C-string begins.
        auto str_addr = p_str as Addr
            
        // STEP 8: Create the final character pointer.
        // *final_ptr is the Pointer (Identity) pointing to the 'char' data.
        auto *final_ptr = str_addr as *char
        
        // STEP 9: Transition sovereignty to Toka's managed String.
        // String::from accepts the Identity (*final_ptr), calculates length, 
        // and performs a deep copy to ensure memory safety.
        return String::from(*final_ptr)
    }
}