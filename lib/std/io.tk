// Copyright (c) 2025 YiZhonghua<zhyi@dpai.com>. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import core/types::{usize, char, ADDR0}
import std/string::{String}
import core/libc::*

// Intrinsic
extern fn println(fmt: str, ...) -> void

pub shape File (
    *handle: void, // FILE*
    opened: bool
)

impl File {
    pub fn open(path: String, mode: String) -> File {
        unsafe {
            auto *p = libc_fopen(path.c_str(), mode.c_str())
            auto valid# = true
            if *p == (ADDR0 as *void) {
                valid# = false
            }
            return File(
                *handle = *p,
                opened = valid
            )
        }
    }
    
    pub fn close(self#) {
        unsafe {
            if self.opened {
                libc_fclose(self.*handle)
                self#.opened = false
                self#.*handle = ADDR0 as *void
            }
        }
    }
    
    pub fn read_to_string(self) -> String {
        unsafe {
            if !self.opened { return String::from("") }
            
            // Get size
            libc_fseek(self.*handle, 0, 2) // SEEK_END
            auto size = libc_ftell(self.*handle)
            libc_rewind(self.*handle)
            
            if size <= 0 { return String::from("") }
            
            // Alloc temp buffer using libc_malloc
            auto *buf# = libc_malloc((size + 1) as usize) as *char
            
            // Read
            auto count = libc_fread(*buf as *void, 1, size as usize, self.*handle)
            buf#[count] = 0 as char
            
            // Make String (copies data)
            auto s = String::from_with_len(*buf, count as i32)
            
            // Free temp
            libc_free(*buf as *void)
            
            return s
        }
    }
    
    pub fn write(self, s: String) -> usize {
        unsafe {
            if !self.opened { return 0 as usize }
            return libc_fwrite(s.c_str() as *void, 1, s.len() as usize, self.*handle)
        }
    }
    pub fn is_eof(self) -> bool {
        unsafe {
            if !self.opened { return true }
            return libc_feof(self.*handle) != 0
        }
    }

    pub fn read_line(self) -> String {
        unsafe {
            if !self.opened { return String::from("") }
            
            auto s = String::from("")
            // Loop char by char
            // TODO: optimize with buffering later if needed
            
            // We use an infinite loop and break
            auto done# = false
            while !done {
                auto c = libc_fgetc(self.*handle)
                
                if c == -1 { // EOF
                    done# = true
                } else {
                    auto ch = c as char
                    s.push_char(ch)
                    if ch == 10 as char { // \n
                        done# = true
                    }
                }
            }
            
            return s
        }
    }

    pub fn flush(self) {
        unsafe {
            if self.opened {
                libc_fflush(self.*handle)
            }
        }
    }

    pub fn seek(self, offset: i64, whence: i32) -> i32 {
        unsafe {
            if !self.opened { return -1 }
            return libc_fseek(self.*handle, offset, whence)
        }
    }

    pub fn tell(self) -> i64 {
        unsafe {
            if !self.opened { return -1:i64 }
            return libc_ftell(self.*handle)
        }
    }
}

// === Global I/O Functions ===

pub fn stdin() -> File {
    unsafe {
        auto *p = libc_fdopen(0, "r" as *char)
        return File(*handle = *p, opened = (*p != nullptr))
    }
}

pub fn stdout() -> File {
    unsafe {
        auto *p = libc_fdopen(1, "w" as *char)
        return File(*handle = *p, opened = (*p != nullptr))
    }
}

pub fn stderr() -> File {
    unsafe {
        auto *p = libc_fdopen(2, "w" as *char)
        return File(*handle = *p, opened = (*p != nullptr))
    }
}

pub fn print(s: String) {
    auto out = stdout()
    out.write(s)
}

// === File Utilities ===

pub fn exists(path: String) -> bool {
    unsafe {
        auto *p = libc_fopen(path.c_str(), "r" as *char)
        if *p != nullptr {
            libc_fclose(*p)
            return true
        }
        return false
    }
}

pub fn remove_file(path: String) -> bool {
    unsafe {
        return libc_remove(path.c_str()) == 0
    }
}

pub fn rename_file(old_path: String, new_path: String) -> bool {
    unsafe {
        return libc_rename(old_path.c_str(), new_path.c_str()) == 0
    }
}
