import core/types::{usize}
import core/traits::{@Hash, @PartialEq, @encap}
import core/option::{Option}
import std/vec::{Vec}
import core/primitives


// HashMap using SOA (Structure of Arrays)
// keys[i], vals[i], meta[i] correspond to the same slot.
pub shape HashMap<K, V> (
    keys#: Vec<K>,
    vals#: Vec<V>,
    meta#: Vec<u8>, // 0=Empty, 1=Occupied
    len: usize,
    cap: usize
)

impl<K, V> HashMap<K, V>@encap {
    fn drop(self#) {
        unsafe {
            // 1. Drop elements
            auto i#: usize = 0
            while i < self.cap {
                 auto *m = self.meta.unsafe_get(i)
                 if m == (1 as u8) {
                     // Drop key
                     auto *ptr_k = self.keys.unsafe_get(i)
                     {
                         auto k = ptr_k // Copy/Move out
                     }
                     
                     // Drop val
                     auto *ptr_v = self.vals.unsafe_get(i)
                     {
                         auto v = ptr_v
                     }
                 }
                 i += 1
            }
            // 2. Vecs (keys, vals, meta) will drop automatically when HashMap drops.
            // Since their len=0, they won't re-drop the elements (garbage or already dropped).
            // They will just free the buffers. Correct.
        }
    }
    
    pub fn clone(self) -> HashMap<K, V> {
        // TODO: Implement proper clone. Recursion in new() caused crash.
        // For now, this is a move, not a clone.
        return self
    }
}

impl<K, V> HashMap<K, V> {
    pub fn new() -> HashMap<K, V> {
        unsafe {
            auto init_cap = 128
            auto k# = Vec<K>::with_capacity(init_cap)
            auto v# = Vec<V>::with_capacity(init_cap)
            auto m# = Vec<u8>::with_capacity(init_cap) // 0 initialized by alloc usually? No, alloc is garbage.
            
            // init_cap is 16 (Power of 2), so we can use bitwise mask optimization

            
            // Manually fill meta with 0
            auto i# = 0
            while i < init_cap {
                 m#.push(0) // This ensures meta has valid 0s up to init_cap
                 i += 1
            }
             
            // For keys/vals, we leave len=0 but cap=16. 
            // We will access them unsafely for efficiency.
            // Since len=0, Vec's own drop won't touch elements (which might be garbage).
            // This is correct behavior for us.
            
            auto map = HashMap<K, V>(
                keys = k,
                vals = v,
                meta = m,
                len = 0,
                cap = init_cap
            )
            
            // Transfer ownership: forget local vecs so they don't drop the buffer.
            k#.unsafe_forget()
            v#.unsafe_forget()
            m#.unsafe_forget()
            
            return map
        }
    }

    pub fn insert(self#, key: K, val: V) {
        auto capacity = self.cap
        // Optimization: capacity is power of 2, use mask
        auto idx# = (key.hash() as usize) band (capacity - 1)
        auto start_idx = idx
        auto should_inc_len# = false
        
        while true {
            unsafe {
                // Check meta
                // auto *m_ptr# declares *m_ptr as the Handle (Ptr to u8).
                // m_ptr is the Soul (u8).
                auto *m_ptr#: u8 = self.meta.unsafe_get(idx)
                
                if m_ptr == (0 as u8) {
                    // Empty slot found
                    m_ptr = (1 as u8) // Mark occupied (Write to Soul)
                    
                    // Write Key
                    auto *k_ptr#: K = self.keys.unsafe_get(idx)
                    k_ptr = key // Write key to Soul
                    
                    // Write Val
                    // Write Val
                    auto *v_ptr#: V = self.vals.unsafe_get(idx)
                    v_ptr = val // Write val to Soul
                    
                    should_inc_len = true
                    break
                }
                
                // Occupied. Check Key match.
                auto *k_ptr#: K = self.keys.unsafe_get(idx)
                if k_ptr.eq(key) {
                    // Overwrite Val
                    auto *v_ptr#: V = self.vals.unsafe_get(idx)
                    v_ptr = val
                    break
                }
            }
            
            idx = (idx + 1) band (capacity - 1)
            if idx == start_idx { break }
        }
        
        if should_inc_len {
            self.len = self.len + (1 as usize)
        }
    }
    
    pub fn get(self, key: K) -> Option<V> {
         auto capacity = self.cap
         auto idx# = (key.hash() as usize) band (capacity - 1)
         auto start_idx = idx
         
         while true {
             unsafe {
                 auto *m_ptr#: u8 = self.meta.unsafe_get(idx)
                 
                 if m_ptr == (0 as u8) {
                     return Option<V>::None
                 }
                 
                 // Occupied, check key
                 auto *k_ptr#: K = self.keys.unsafe_get(idx)
                 if k_ptr.eq(key) {
                     auto *v_ptr#: V = self.vals.unsafe_get(idx)
                     return Option<V>::Some(v_ptr)
                 }
             }
             
             idx = (idx + 1) band (capacity - 1)
             if idx == start_idx {
                 return Option<V>::None
             }
         }
         return Option<V>::None
    }


    pub fn iter(self) -> HashMapIterator<K, V> {
        unsafe {
             return HashMapIterator<K, V>(
                 keys_ptr = self.keys.unsafe_get(0),
                 vals_ptr = self.vals.unsafe_get(0),
                 meta_ptr = self.meta.unsafe_get(0),
                 cap  = self.cap,
                 pos  = 0
             )
        }
    }
}

pub shape Entry<K, V> (
    key: K,
    val: V
)

alias MapResult<K, V> = Option<Entry<K, V>>

pub shape HashMapIterator<K, V> (
    *keys_ptr: K,
    *vals_ptr: V,
    *meta_ptr: u8,
    cap: usize,
    pos#: usize
)

impl<K, V> HashMapIterator<K, V> {
    pub fn next(self) -> MapResult<K, V> {
        unsafe {
            // Acquire pointers locally
            // auto *p: T declares p as *T.
            // self.*ptr returns Handle (*T).
            auto *m_buf: u8 = self.*meta_ptr
            auto *k_buf: K = self.*keys_ptr
            auto *v_buf: V = self.*vals_ptr
            
            while self.pos < self.cap {
                // Index unhatted -> Value
                if m_buf[self.pos] == (1 as u8) {
                    auto k = k_buf[self.pos]
                    auto v = v_buf[self.pos] // Copy value
                    
                    self.pos += 1
                    return MapResult<K, V>::Some(Entry<K, V>(key=k, val=v))
                }
                self.pos += 1
            }
            return MapResult<K, V>::None
        }
    }
}
