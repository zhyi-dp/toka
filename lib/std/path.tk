// Copyright (c) 2025 YiZhonghua<zhyi@dpai.com>. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import std/string::{String}
import core/types::{char, Addr}

/**
 * Path Utilities
 */

pub fn join(base: String, sub: String) -> String {
    auto res# = String::from(base.c_str())
    if res.len() > 0 {
        auto last = res.at(res.len() - 1)
        if last != 47:char { // '/'
            res#.push_char(47:char)
        }
    }
    
    auto sub_start# = 0
    if sub.len() > 0 {
        if sub.at(0) == 47:char {
            sub_start = 1
        }
    }
    
    // Manual sub-string append
    unsafe {
        auto *p = sub.c_str()
        auto addr = *p as Addr
        auto *sub_p = (addr + sub_start as Addr) as *char
        res#.push_str(*sub_p)
    }
    
    return res
}

pub fn extension(path: String) -> String {
    auto idx = path.find_char(46:char) // '.'
    if idx == -1 {
        return String::from("")
    }
    
    // Find last dot
    auto last_dot# = idx
    auto i# = idx + 1
    while i < path.len() {
        if path.at(i) == 46:char {
            last_dot = i
        }
        i = i + 1
    }
    
    unsafe {
        auto *p = path.c_str()
        auto addr = *p as Addr
        auto *sub_p = (addr + (last_dot + 1) as Addr) as *char
        return String::from(*sub_p)
    }
}

pub fn basename(path: String) -> String {
    auto last_slash# = -1
    auto i# = 0
    while i < path.len() {
        if path.at(i) == 47:char { // '/'
            last_slash = i
        }
        i = i + 1
    }
    
    if last_slash == -1 {
        return String::from(path.c_str())
    }
    
    unsafe {
        auto *p = path.c_str()
        auto addr = *p as Addr
        auto *sub_p = (addr + (last_slash + 1) as Addr) as *char
        return String::from(*sub_p)
    }
}

pub fn dirname(path: String) -> String {
    auto last_slash# = -1
    auto i# = 0
    while i < path.len() {
        if path.at(i) == 47:char { // '/'
            last_slash = i
        }
        i = i + 1
    }
    
    if last_slash == -1 {
        return String::from(".")
    }
    
    if last_slash == 0 {
        return String::from("/")
    }
    
    unsafe {
        auto *p = path.c_str()
        return String::from_with_len(*p, last_slash)
    }
}

pub fn is_absolute(path: String) -> bool {
    if path.len() > 0 {
        if path.at(0) == 47:char { return true } // '/'
    }
    return false
}

pub fn file_stem(path: String) -> String {
    auto base = basename(path)
    auto ext_idx = base.find_char(46:char) // '.'
    if ext_idx == -1 {
        return base
    }
    if ext_idx == 0 {
        return base // ".hidden"
    }
    
    unsafe {
        return String::from_with_len(base.c_str(), ext_idx)
    }
}

pub fn with_extension(path: String, ext: String) -> String {
    auto stem_path# = path
    
    // Remove existing extension if any
    auto ext_idx = path.find_char(46:char)
    if ext_idx != -1 {
        unsafe {
            stem_path = String::from_with_len(path.c_str(), ext_idx)
        }
    }
    
    // Append new
    auto res# = stem_path
    
    // Check if ext is empty
    if ext.len() == 0 {
        return res
    }
    
    res#.push_char(46:char)
    
    // Skip leading dot in ext if present
    auto ext_start# = 0
    if ext.at(0) == 46:char {
        ext_start = 1
    }
    
    unsafe {
        auto *p = ext.c_str()
        auto addr = *p as Addr
        auto *sub_p = (addr + ext_start as Addr) as *char
        res#.push_str(*sub_p)
    }
    
    return res
}
