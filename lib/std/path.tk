// Copyright (c) 2025 YiZhonghua<zhyi@dpai.com>. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import std/string::{String}
import core/types::{char, Addr}

/**
 * Path Utilities
 */

pub fn join(base: String, sub: String) -> String {
    auto res# = String::from(base.c_str())
    if res.len() > 0 {
        auto last = res.at(res.len() - 1)
        if last != 47:char { // '/'
            res#.push_char(47:char)
        }
    }
    
    auto sub_start# = 0
    if sub.len() > 0 {
        if sub.at(0) == 47:char {
            sub_start = 1
        }
    }
    
    // Manual sub-string append
    unsafe {
        auto *p = sub.c_str()
        auto addr = *p as Addr
        auto *sub_p = (addr + sub_start as Addr) as *char
        res#.push_str(*sub_p)
    }
    
    return res
}

pub fn extension(path: String) -> String {
    auto idx = path.find_char(46:char) // '.'
    if idx == -1 {
        return String::from("")
    }
    
    // Find last dot
    auto last_dot# = idx
    auto i# = idx + 1
    while i < path.len() {
        if path.at(i) == 46:char {
            last_dot = i
        }
        i = i + 1
    }
    
    unsafe {
        auto *p = path.c_str()
        auto addr = *p as Addr
        auto *sub_p = (addr + (last_dot + 1) as Addr) as *char
        return String::from(*sub_p)
    }
}

pub fn basename(path: String) -> String {
    auto last_slash# = -1
    auto i# = 0
    while i < path.len() {
        if path.at(i) == 47:char { // '/'
            last_slash = i
        }
        i = i + 1
    }
    
    if last_slash == -1 {
        return String::from(path.c_str())
    }
    
    unsafe {
        auto *p = path.c_str()
        auto addr = *p as Addr
        auto *sub_p = (addr + (last_slash + 1) as Addr) as *char
        return String::from(*sub_p)
    }
}

pub fn dirname(path: String) -> String {
    auto last_slash# = -1
    auto i# = 0
    while i < path.len() {
        if path.at(i) == 47:char { // '/'
            last_slash = i
        }
        i = i + 1
    }
    
    if last_slash == -1 {
        return String::from(".")
    }
    
    if last_slash == 0 {
        return String::from("/")
    }
    
    unsafe {
        auto *p = path.c_str()
        return String::from_with_len(*p, last_slash)
    }
}
