import "core/io";

struct Point {
    x: i32,
    y: i32
}

fn takes_i32(a: i32) {
    return;
}

fn modify(arg: i32) {
    // arg# = 20; // Error: arg is not mutable
    return;
}

fn main() {
    // 1. Type mismatch in assignment (Implicit conversion disabled)
    let a: i64 = 10;
    let b: i32 = a; // Error: i64 to i32

    // 2. Type mismatch in function call
    takes_i32(a); // Error: expected i32, got i64

    // 3. Mutability violation (Assigning to immutable)
    let c = 5;
    c# = 10; // Error: c is immutable

    // 4. Mutation without token
    let d# = 10;
    d = 20; // Error: Missing # at usage site (If we enforce this at usage site)

    // 5. Binary operation type mismatch
    // (We will use explicit types to trigger it until parser supports : annotation in expressions)
    let e1: i32 = 10;
    let e2: i64 = 20;
    let e3 = e1 + e2; // Error: i32 + i64

    // 6. Struct initialization type mismatch
    let p = Point { x = a, y = 20 }; // Error: x expects i32, a is i64

    return;
}
