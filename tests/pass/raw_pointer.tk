// Copyright (c) 2025 YiZhonghua<zhyi@dpai.com>. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import std/io::println
import std/io::println
import std/debug::assert
import std/memory

shape Hero (
    id: i32,
    hp: i32
)

fn main() -> i32 {
    // 1. 堆分配与初始化 (Scalar Heap Alloc)
    // 根据 1.1: alloc i32(42)
    auto *p = unsafe alloc i32(42)
    
    unsafe {
        // 根据 4: 访问必须通过下标，p[0] 代表实体内容
        println("Scalar Value: {} (expected 42)", p[0])
        assert(p[0] == 42, "p[0] mismatch")
        println("Address: {}", *p)
        
        // 根据 7: 手动释放
        free *p
    }

    // 2. 数组分配与算术 (Array Alloc & Stride)
    // 根据 1.2: alloc [5]i32(0) 映射为 memset 0
    auto *arr# = (unsafe alloc [5]i32(0)) as *i32
    unsafe {
        arr#[0] = 10
        arr#[1] = 20
        
        // 根据 5: 轨道 B - 元素偏移 (Item Stride)
        // *arr[1] 获取第二个元素的地址
        auto *p_second = *arr[1] 
        println("Stride Access: {} (expected 20)", p_second[0])
        
        // 根据 5: 轨道 A - 字节偏移 (Byte Offset)
        // *arr + 4 偏移 4 字节（即一个 i32 的宽度）
        auto *p_offset = (*arr + 4) as *i16
        println("Byte Offset Access: {} (expected 20)", p_offset[0])
        assert(p_second[0] == 20, "stride mismatch")
        // No assert for p_offset[0] as i16 logic complex to verify in token
        
        free *arr
    }

    // 3. 结构体访问 (Struct Access)
    unsafe {
        // 根据 1.3: 结构体分配
        auto *h# = alloc Hero(id = 7, hp = 100)
        // 根据 4: 成员直接访问
        println("Hero ID: {} (expected 7)", h.id)
        
        h#.hp = 80
        println("Hero HP: {} (expected 80)", h.hp)
        assert(h.id == 7, "h.id mismatch")
        assert(h.hp == 80, "h.hp mismatch")
        
        free *h
    }

    // 4. 栈地址获取 (Stack Address)
    // 根据 3: *variable 获取栈地址，属于 SAFE
    auto stack_val = 123:i32
    auto *p_stack# = *stack_val
    
    unsafe {
        p_stack#[0] = 456
        println("Stack Modified: {} (expected 456)", stack_val)
        assert(stack_val == 456, "stack_val mismatch")
    }

    // 5. 权限管理 (Permissions)
    // 根据 8: 允许权限升级 (Trust the Human)
    auto val = 1:i32
    auto *px = *val
    auto *px_mut# = *px // 权限升级: Const -> Mut
    
    unsafe {
        px_mut#[0] = 2
        println("Permission Upgrade: val={} (expected 2)", val)
        assert(val == 2, "val mismatch after upgrade")
    }

    // 6. 空值检查 (Null Check)
    // 根据 7: *ptr == null 属于 SAFE
    auto *?empty:Hero = nullptr
    if nullptr == *empty {
        println("Null pointer confirmed")
        assert(true, "Null pointer check passed")
    }

    return 0
}