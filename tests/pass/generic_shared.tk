import std/io::println

// --- 基础类型 ---
impl u64 {
    fn fetch_add(self#) {
        println("type u64 enter .fetch_add, now is {}", self)
        self# += 1 
    }
    fn fetch_sub(self#) { 
        println("type u64 enter .fetch_sub, now is {}", self)
        self# -= 1 
    }
    fn load(self) -> u64 { 
        println("type u64 enter .load, now is {}", self)
        return self 
    }
    fn store(self#, val: u64) {
        println("type u64 enter .store, now is {}, will set to {}", self, val)
        self# = val 
    }
}

// --- 引用计数控制块 ---
shape RcWrapper<T>(
    ref_count#: u64,
    *data: T
)

// --- 智能指针主体 ---
shape SharedPtr<T>(
    *#wrapper: RcWrapper<T>
)

impl<T> SharedPtr<T> {
    
    // 1. 静态构造
    pub fn make(val: T) -> SharedPtr<T> {
        unsafe {
            // [Alloc Syntax]: 按照你的要求，*data 接收 *ptr
            println("allocating for {}", val)
            auto *data_ptr = unsafe alloc T(val)
            
            auto *cb_ptr = unsafe alloc RcWrapper<T>(
                ref_count = 1, 
                *data = *data_ptr 
            )
            cb_ptr.ref_count#.store(1)
            
            return SharedPtr<T>(*wrapper = *cb_ptr)
        }
    }

    // 2. 拷贝赋值：修复了逻辑顺序和帽子规则解引用
    pub fn assign(self#, rhs: SharedPtr<T>) {
        // [帽子规则]: 比较指针地址不需要解引用
        if self.*#wrapper == rhs.*wrapper {
            return
        }

        // [逻辑修复]: 必须先释放旧值 (DecRef/Free)
        self.drop() 

        // 接纳新值
        self.*#wrapper = rhs.*wrapper

        // [帽子规则]: 原始指针必须显式解包 (*ptr) 才能访问成员
        if self.*wrapper != nullptr {
            self.wrapper.ref_count#.fetch_add()
        }
    }

    // 3. 析构函数：帽子规则严谨版
    pub fn drop(self#) {
        println("enter .drop")   
        if self.*wrapper == nullptr {   
            return
        }

        // [帽子规则]: (*ptr).member
        self.wrapper.ref_count#.fetch_sub()

        unsafe println("enter .drop for addr {} with ref_count {}", self.wrapper.*data as OAddr, self.wrapper.ref_count)   

        if self.wrapper.ref_count.load() == 0 {   
            unsafe {
                println("dropping for addr {}, val is {}", self.wrapper.*data as OAddr, self.wrapper.*data[0])
                // 1. 先释放数据
                // (*self.wrapper) -> 拿到 RcWrapper
                // .data -> 拿到 *T
                unsafe free self.wrapper.*data
                
                // 2. 再释放控制块
                unsafe free self.*wrapper
            }
        }
        
        // 置空
        self.*wrapper = nullptr
 
    }
}

// --- 测试逻辑 ---
fn main() -> i32 {
    unsafe {
        auto sp1 = SharedPtr<i32>::make(10)
        
        auto sp2 = SharedPtr<i32>::make(20) 
        println("will assign sp2 to sp1")
        sp2.assign(sp1) // sp2 Drop old(20), Acquire sp1(10)
        println("assign sp2 to sp1 done")
        

        auto sp3 = SharedPtr<i32>::make(30)
        println("will assign sp3 to sp1")
        sp3.assign(sp1)
        println("assign sp3 to sp1 done")
        
        // 此时 ref_count 应该是 3
        
        sp2.drop()
        sp1.drop()
        sp3.drop() // Count -> 0, Free
    }
    return 0
}