import std/io::println

shape Atomic<T> (
    t:T
)
// --- 基础类型 ---
impl<T> Atomic<T> {
    fn fetch_add(self#) {
        //println("type u64 enter .fetch_add, now is {}", self)
        self.t# += 1 
    }
    fn fetch_sub(self#) { 
        //println("type u64 enter .fetch_sub, now is {}", self)
        self.t# -= 1 
    }
    fn load(self) -> T { 
        //println("type u64 enter .load, now is {}", self)
        return self.t 
    }
    fn store(self#, val: T) {
        //println("type u64 enter .store, now is {}, will set to {}", self, val)
        self.t# = val 
    }
}

// --- 引用计数控制块 ---
shape RcWrapper<T>(
    ref_count#: Atomic<u64>,
    *data: T
)

// --- 智能指针主体 ---
shape SharedPtr<T>(
    *#wrapper: RcWrapper<T>
)

impl<T> SharedPtr<T>@encap {
    fn drop(self#) {
        println("comple call .drop, shared_ptr:{} wrapper:{}", *self as OAddr, self.*wrapper as OAddr)
    }
}

impl<T> SharedPtr<T> {
    
    // 1. 静态构造
    pub fn make(val: T) -> SharedPtr<T> {
        unsafe {
            // [Alloc Syntax]: 按照你的要求，*data 接收 *ptr
            //println("allocating for {}", val)
            auto *data_ptr# = unsafe alloc T(val)
            auto rc1 = Atomic<u64>(1)
            auto *cb_ptr# = unsafe alloc RcWrapper<T>(
                ref_count = rc1, 
                *data = *data_ptr 
            )
            // cb_ptr.ref_count#.store(1)
            println("make++++ wrapper:{} data:{} val = {}", *cb_ptr as OAddr, *data_ptr as OAddr, data_ptr)
            return SharedPtr<T>(*wrapper = *cb_ptr)
        }
    }

    // 2. 拷贝赋值：修复了逻辑顺序和帽子规则解引用
    pub fn assign(self#, rhs: SharedPtr<T>) {
        // [帽子规则]: 比较指针地址不需要解引用
        if self.*wrapper == rhs.*wrapper {
            unsafe println("lhs wrapper:{} == rhs wrapper:{} val = {}", self.*wrapper as OAddr, rhs.*wrapper as OAddr, rhs.wrapper.data)
            return
        }
        unsafe println("lhs wrapper:{} <- rhs wrapper:{} val = {}", self.*wrapper as OAddr, rhs.*wrapper as OAddr, rhs.wrapper.data[0])

        // [逻辑修复]: 必须先释放旧值 (DecRef/Free)
        self.xdrop() 

        // 接纳新值
        self.*#wrapper = rhs.*wrapper

        // [帽子规则]: 原始指针必须显式解包 (*ptr) 才能访问成员
        if self.*wrapper != nullptr {
            self.wrapper.ref_count#.fetch_add()
        }
    }

    // 3. 析构函数：帽子规则严谨版
    pub fn xdrop(self#) {
        println("enter .xdrop, shared_ptr:{} wrapper:{}", *self as OAddr, self.*wrapper as OAddr)
        if self.*wrapper == nullptr {   
            return
        }

        // [帽子规则]: (*ptr).member
        self.wrapper.ref_count#.fetch_sub()

        println("try xdrop for addr {} with ref_count={}", self.wrapper.*data as OAddr, self.wrapper.ref_count)   

        if self.wrapper.ref_count.load() == 0 {   
            unsafe {
                println("drop---- wrapper:{} data:{} val={}", self.*wrapper as OAddr, self.wrapper.*data as OAddr, self.wrapper.data)
                // 1. 先释放数据
                // (*self.wrapper) -> 拿到 RcWrapper
                // .data -> 拿到 *T
                unsafe free self.wrapper.*data
                
                // 2. 再释放控制块
                unsafe free self.*wrapper
                
                // 置空 (在 unsafe 块内允许非空 raw 指针接收 nullptr)
                self.*#wrapper = nullptr
            }
        }
        else
        {
            println("xdrop for addr {} with ref_count={} NOT dropped", self.wrapper.*data as OAddr, self.wrapper.ref_count)
        }
        
 
    }

    pub fn new(val: T) -> SharedPtr<T> {
        unsafe {
            // [Fix] Use alloc to create initialized mutable RcWrapper directly
            // This avoids casting issues and ensures correct mutable pointer type
            auto *val_ptr = unsafe alloc T(val)
            auto *cb# = unsafe alloc RcWrapper<T>(
                ref_count = Atomic<u64>(1),
                *data = *val_ptr
            )
            return SharedPtr<T>(*wrapper = *cb)
        }
    }
}

alias SharedPtrX = SharedPtr<u64>
// --- 测试逻辑 ---
fn main() -> i32 {
    unsafe {
        auto sp1# = SharedPtrX::make(10)
        auto sp2# = SharedPtrX::make(20) 

        //auto sp11 = sp1;
        //auto sp22 = sp2;
        //auto sp33 = sp3;
        
        sp2#.assign(sp1)
        sp1#.assign(sp1)

        auto sp3# = SharedPtrX::make(30)
        sp1#.assign(sp3)
        sp1#.assign(sp2)
        sp1#.assign(sp1)
        
        sp1#.xdrop()
        sp2#.xdrop()
        sp3#.xdrop() // Count -> 0, Free
    }
    return 0
}