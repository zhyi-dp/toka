// tests/pass/test_comprehensive.tk
// A comprehensive tour of Toka v1.3 features

import std/io::println
import std/memory::assert
import core/types::LIMITS
import std/string::String

// --- 1. Enumerations & ADTs ---

shape Status (
    Active = 0 |
    Inactive = 1 |
    Paused = 2
)

shape Color (
    Red |
    Green |
    Blue |
    Custom(u8, u8, u8)
)

// --- 2. Traits ---

trait @Renderable {
    pub fn render(self) -> i32
}

trait @Identity {
    pub fn get_id(self) -> i32
}

// --- 3. Structs ---

shape Point (
    x: f32,
    y: f32
)

shape Entity (
    id: i32,
    pos: Point,
    status: Status,
    name: String
)

// --- 4. Implementations ---

impl Point {
    // Method with mutable self (in-place capture)
    pub fn add(self#, other: Point) {
        self#.x = self.x + other.x
        self#.y = self.y + other.y
    }
}

impl Entity@Renderable {
    pub fn render(self) -> i32 {
        // Accessing underlying pointer of String
        println("Rendering Entity '{}' (#{}) at ({}, {}) Status: {}", 
            self.name.c_str(), self.id, self.pos.x, self.pos.y, self.status)
        return 1
    }
}

impl Entity@Identity {
    pub fn get_id(self) -> i32 {
        return self.id
    }
}

// Polymorphic function accepting a Trait Object
fn print_id(obj: dyn @Identity) {
    println("ID is: {}", obj.get_id())
}

// --- 5. Logic & Control Flow ---

fn simulate(e#: Entity) -> bool {
    // specific ADT match
    match e.status {
        Status::Inactive => return false
        _ => {}
    }

    // struct mutation
    e#.pos.add(Point(x=1.0:f32, y=0.5:f32))

    // logic check
    if e.pos.x > 100.0:f32 {
        e#.status = Status::Inactive
        return false
    }

    return true
}

fn color_to_hex(c: Color) -> i32 {
    // ADT Pattern Matching with Destructuring
    // Note: Implicitly namespaced variants or explicit?
    // Using matches with 'Color::' prefix for clarity
    return match c {
        Color::Red => pass 0xFF0000
        Color::Green => pass 0x00FF00
        Color::Blue => pass 0x0000FF
        auto Color::Custom(r, g, b) => {
            // Expression block with 'pass'
            pass (r as i32) * 65536 + (g as i32) * 256 + (b as i32)
        }
    }
}

// --- 6. Main Execution ---

fn main() -> i32 {
    println("--- Toka Comprehensive Test ---")

    // 6.1 String & Allocations
    auto name_str = String::from("Hero")
    
    // stack allocation
    // Entity takes ownership of the String buffer (via bitwise copy)
    auto e1# = Entity(
        id = 1,
        pos = Point(10.0:f32, 20.0:f32),
        status = Status::Active,
        name = name_str 
    )
    println("hello {}",e1.name.c_str())

    // 6.2 Trait Object (Polymorphism)
    print_id(e1)

    // 6.3 Loop & Logic
    auto steps# = 0
    auto max_steps = 3
    
    // Loop expression with result
    auto result_code = loop {
        if steps >= max_steps {
            break 200 // OK
        }
        
        println("Step: {}", steps)
        if !simulate(e1#) {
            break 500 // Error
        }
        
        // Assert intermediate state by calling render
        e1.render()
        steps# += 1
    }
    
    println("Loop finished with code: {}", result_code)
    assert(result_code == 200, "Loop result mismatch")
    assert(steps == 3, "Step count mismatch")
    
    // Verifying mutation results
    // Init: (10, 20). 3 steps of (+1.0, +0.5).
    // Final: (13.0, 21.5)
    assert(e1.pos.x == 13.0:f32, "pos.x mismatch")
    assert(e1.pos.y == 21.5:f32, "pos.y mismatch")

    // 6.4 ADT & Pattern Matching
    auto c1 = Color::Red()
    auto c2 = Color::Custom(10, 20, 30) // 0x0A141E
    
    auto h1 = color_to_hex(c1)
    auto h2 = color_to_hex(c2)
    
    println("Color Red: 0x{}", h1)
    println("Color Custom: 0x{}", h2)
    
    assert(h1 == 0xFF0000, "Red hex mismatch")
    assert(h2 == 0x0A141E, "Custom hex mismatch")

    // 6.5 Unique Pointer & Move Semantics
    {
        println("\n-- Testing Unique Pointers --")
        // Heap allocation
        auto ^ptr = new Point(x=999.0:f32, y=888.0:f32)
        println("Heap Point: ({}, {})", ptr.x, ptr.y)
        
        // Pointer Move
        auto ^ptr2 = ^ptr
        // ptr is now moved-from
        println("Moved Point: ({}, {})", ptr2.x, ptr2.y)
        assert(ptr2.x == 999.0:f32, "Moved pointer value mismatch")
        // Automatic cleanup of ptr2 at end of scope
    }
    
    println("All comprehensive tests passed.")
    return 0
}
