// Copyright (c) 2025 YiZhonghua<zhyi@dpai.com>. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import std/io::println

// 1. Trait Definition
trait @Shape {
    pub fn area(self) -> i32
}

// 2. Concrete Shapes
shape Rect(w: i32, h: i32)
shape Square(s: i32)

// 3. Implementations
impl Rect@Shape {
    pub fn area(self) -> i32 { 
        return self.w * self.h 
    }
}

impl Square@Shape {
    pub fn area(self) -> i32 { 
        return self.s * self.s 
    }
}

// 4. Dynamic Dispatch Function
// 'dyn @Shape' implies a Trait Object.
// The ABI will automatically pass this as a Fat Pointer (DataPtr, VTablePtr)
// simply because it's a heavy/unsized type, similar to how Structs are passed by implicit ptr.
fn print_dynamic_shape(s: dyn @Shape) -> i32 {
    // Dynamic dispatch happens here via VTable lookup
    auto a = s.area()
    println("Dynamic Area: {}", a)
    return a
}

fn main() -> i32 {
    auto r = Rect(w = 10, h = 20)
    auto q = Square(s = 5)

    // 5. Implicit Coercion (Unsizing)
    // Coercing Rect (Concrete) -> dyn @Shape (Trait Object)
    // No '&' needed. The compiler captures 'r' and 'q' in place.
    assert(print_dynamic_shape(r) == 200, "Rect area mismatch")
    assert(print_dynamic_shape(q) == 25, "Square area mismatch")
    
    return 0
}
