
import std/io::println
import std/debug::assert
import std/memory
import core/traits::{@encap}
import core/types::{OAddr}

shape Node(
    val: i32,
    ^?next: Node
)
impl Node@encap {
    //pub val
    //pub ^?next
    fn drop(self#) {
        println("dropping {}", self.val)
    }
}

impl Node {
    fn unwrap(^?self: Node) -> &Node <- self {
        if ^?self is ^self {
            return &self
        }
        assert(false, "unwrap null")
        return &self
    }
}

fn unwrap(^?p: Node) -> &Node <- p {
    if ^?p is ^p {
        return &p
    }
    assert(false, "unwrap null")
    return &p
}

pub fn main() -> i32 {
    {
        auto node111 = Node(val=111, ^?next=nullptr)
        auto ^node222 = new Node(val=222, ^?next=nullptr) 
        auto ~node333 = new Node(val=333, ^?next=nullptr) 

        auto *node444 = unsafe alloc Node(val=444, ^?next=nullptr) 
        unsafe free *node444

        auto ^node2 = ^node222
    }
    // User's logic + Print checks
    auto ^#head = new Node(val=0, ^?next=nullptr)  
    println("head: {}", head.val)
    assert(head.val == 0, "check head.val")
    // Push 1
    {
        for auto i in [1,2,3,4,5] {
            auto ^next = ^head
            ^#head = new Node(val=i, ^?next=^next)
            println("[{}]pushed: {}, address: {}", i, head.val, ^head as OAddr)
            assert(head.val == i, "check head.val")
        }
    }
    
    auto ^#cursor = ^head 
    println("^#cursor address {}", ^cursor as OAddr)
    auto i# = 5
    loop {
        assert(i >= 0, "check i >= 0")
        println("[{}]val: {}", i, cursor.val)
        assert(cursor.val == i, "check cursor.val")
        i# -= 1
        if i == 4 {
            //break
        }
        
        if cursor.^?next is cursor.^next {
            println("will reseat to {}", cursor.^next as OAddr)
            ^#cursor = cursor.^next 
            println("^#cursor address {}", ^cursor as OAddr)
        } else {
            break
        }
    }
    return 0
}