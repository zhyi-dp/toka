// Copyright (c) 2025 YiZhonghua<zhyi@dpai.com>. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// --- Physical Shape Definitions ---
import std/io::println
import std/memory::assert
shape RawBytes [u8; 4]
shape Point (u8, u8, u8, u8)

// --- Tagged Union Test ---
shape Result(
    Ok(u32) = 0 | 
    Err(u32) = 1
)

fn test_match_expr(val: u32) -> u32 {
    // Explicitly specify the namespace to maintain physical transparency
    auto res = Result::Ok(val)
    
    // match expression: enables value-merging logic (PHI node / result slot)
    auto outcome = match res {
        auto Result::Ok(v) => {
            pass v * 2 // 'pass' is correct: it delivers a value inside the match block to 'outcome'
        }
        auto Result::Err(e) => {
            pass 0     // 'pass' is correct: it delivers a value inside the match block to 'outcome'
        }
    }
    
    return outcome
}

// --- Binding Sovereignty Test (Reference Deconstruction) ---
fn test_binding_refs(val: u32) -> u32 {
    auto res = Result::Ok(val)
    
    match res {
        // &v is a read-only binding to the Payload memory address; no copy occurs
        auto Result::Ok(&v) => {
            return v   // 'return' is required here: the match block has no receiver
        }
        _ => { 
            return 0   // 'return' is required here: the match block has no receiver
        }
    }
}

fn main() -> i32 {
    auto b = test_match_expr(10)
    if b != 20:u32 { 
        println("Match expr error")
        return 2 
    }
    assert(b == 20:u32, "b mismatch")
    
    auto c = test_binding_refs(42)
    if c != 42:u32 { 
        println("Binding refs error")
        return 3 
    }
    assert(c == 42:u32, "c mismatch")
    
    return 0
}