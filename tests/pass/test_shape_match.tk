// --- Physical Shape Definitions ---
import std/io::println
import std/memory::assert
shape RawBytes [u8; 4]
shape Point (u8, u8, u8, u8)

// --- Tagged Union Test ---
shape Result(
    Ok(u32) = 0 | 
    Err(u32) = 1
)

fn test_match_expr(val: u32) -> u32 {
    // Explicitly specify the namespace to maintain physical transparency
    auto res = Result::Ok(val)
    
    // match expression: enables value-merging logic (PHI node / result slot)
    auto outcome = match res {
        auto Result::Ok(v) => {
            pass v * 2 // 'pass' is correct: it delivers a value inside the match block to 'outcome'
        }
        auto Result::Err(e) => {
            pass 0     // 'pass' is correct: it delivers a value inside the match block to 'outcome'
        }
    }
    
    return outcome
}

// --- Binding Sovereignty Test (Reference Deconstruction) ---
fn test_binding_refs(val: u32) -> u32 {
    auto res = Result::Ok(val)
    
    match res {
        // &v is a read-only binding to the Payload memory address; no copy occurs
        auto Result::Ok(&v) => {
            return v   // 'return' is required here: the match block has no receiver
        }
        _ => { 
            return 0   // 'return' is required here: the match block has no receiver
        }
    }
}

fn main() -> i32 {
    auto b = test_match_expr(10)
    if b != 20 { 
        println("Match expr error")
        return 2 
    }
    assert(b == 20, "b mismatch")
    
    auto c = test_binding_refs(42)
    if c != 42 { 
        println("Binding refs error")
        return 3 
    }
    assert(c == 42, "c mismatch")
    
    return 0
}