// targets/pass/complex_generic.tk
import core/traits::{@encap}
import std/io::println
// 1. 常量泛型 (-1阶)
shape Buffer<T, N_: usize>(
    data: [T; N_], // 使用 N_ 作为数组长度
    len: usize
)

// 2. 递归泛型 (0阶) + 嵌套使用
shape Node<T>(
    // 嵌套：Node 里面有个 Buffer，大小固定为 16
    buf: Buffer<T, 5>, 
    
    // 递归：指向下一个同类型节点
    ^?next: Node<T> 
)
impl<T> Node<T>@encap {
    pub buf
    fn drop(self#) {
        println("dropping Node")
    }
}
/*
trait MyDrop {
    fn mydrop(self#)
}
impl Node<i32>@MyDrop {
    fn mydrop(self#) {
        println("dropping Node")
    }
}
*/
fn main() -> i32 {
    // 3. 实例化
    // 这会触发一连串单态化：
    // Node<i32> -> Buffer<i32, 5> -> [i32; 5]
    
    auto ^head: Node<i32> = new Node<i32>(
        // 使用数组重复初始化语法 [val; count] 编译器内部使用 memset 来高效的实现数组的广播初始化逻辑
        // 这里需要编译器能识别 [0; 5] 匹配 [i32; 5]
        buf = Buffer<i32, 5>(data=[0,1,2,3,4], len=5), 
        
        ^?next = nullptr
    )
    for auto i in [0,1,2,3,4] {
        println("head.buf.data[{}] = {}", i, head.buf.data[i])
        assert(head.buf.data[i] == i,"check head.val[{}]")
    }
    //head.mydrop()
    return 0
}