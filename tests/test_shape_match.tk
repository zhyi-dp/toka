// --- Physical Shape Definitions ---
shape RawBytes [u8; 4]
shape Point (u8, u8, u8, u8)

fn test_violent_aesthetics() -> u32 {
    auto bytes = RawBytes[1, 2, 3, 4]
    
    // Physical reinterpretation via 'as': zero-cost bitcast
    auto p = bytes as shape(u8, u8, u8, u8)
    
    // Physical honesty: p is just a new interpretation of the 'bytes' address;
    // direct access to tuple index .0
    return p.0 as u32
}

// --- Tagged Union Test ---
shape Result(
    Ok(u32) = 0 | 
    Err(u32) = 1
)

fn test_match_expr(val: u32) -> u32 {
    // Explicitly specify the namespace to maintain physical transparency
    auto res = Result::Ok(val)
    
    // match expression: enables value-merging logic (PHI node / result slot)
    auto outcome = match res {
        auto Result::Ok(v) => {
            pass v * 2 // 'pass' is correct: it delivers a value inside the match block to 'outcome'
        }
        auto Result::Err(e) => {
            pass 0     // 'pass' is correct: it delivers a value inside the match block to 'outcome'
        }
    }
    
    return outcome
}

// --- Binding Sovereignty Test (Reference Deconstruction) ---
fn test_binding_refs(val: u32) -> u32 {
    auto res = Result::Ok(val)
    
    match res {
        // &v is a read-only binding to the Payload memory address; no copy occurs
        auto Result::Ok(&v) => {
            return v   // 'return' is required here: the match block has no receiver
        }
        _ => { 
            return 0   // 'return' is required here: the match block has no receiver
        }
    }
}

fn main() -> i32 {
    auto a = test_violent_aesthetics()
    if a != 1 { return 1 }
    
    auto b = test_match_expr(10)
    if b != 20 { return 2 }
    
    auto c = test_binding_refs(42)
    if c != 42 { return 3 }
    
    return 0
}