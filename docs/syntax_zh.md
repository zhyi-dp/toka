# Toka 语法说明 按表格罗列 

| 代码示例 | 说明 | 要点/铁律 |
| :--- | :--- | :--- |
| **基础结构** | | |
| `fn main() -> i32 { ... }` | 主函数 | 必须返回 `i32`，通常返回 0 |
| `import std/io::*` | 模块导入 | 无分号，使用双冒号 `::` 分隔 |
| `// comment` | 注释 | 仅支持单行注释 |
| `/* comment */` | 注释 | 多行注释 |
| **变量与可变性** | | |
| `auto x = 1` | 变量声明 | 默认为不可变，自动类型推断 |
| `auto x# = 1` | 可变变量 | 变量名后加 `#` 表示可变 (Mutable) |
| `auto x? = 1` | 可空变量 | `?` 表示可为 `nullptr` 或无效值 (Nullable) |
| `auto x! = 1` | 可空且可变 | `!` 是 `?` + `#` 的组合，即 Nullable + Mutable |
| `x = 2` | 赋值 | 仅具备可变性 (`#` 或 `!`) 的变量可被重新赋值 |
| `auto x: i64 = 10` 或 `auto x = 10:i64` | 显式类型 | 变量定义后跟类型，或字面量后跟类型 |
| **函数与方法** | | |
| `fn add(a: i32, b: i32) -> i32` | 函数定义 | 参数需显式类型，`->` 后跟返回类型 |
| `impl MyShape { fn method(self) }` | 方法定义 | `impl` 块定义类型方法 |
| `fn mut_method(obj#)` | 可变方法 | `obj#` 声明参数可变，调用时必须显式标注：`o#.m()` |
| `obj.method()` | 方法调用 | 点号调用 |
| **数据结构 (Shape)** | | |
| `shape Point(x: i32, y: i32)` | 结构体 (Struct) | 使用圆括号，字段需命名 |
| `shape Vec(*?buf#: T)` | 成员属性 | 字段后可跟属性符号: `?`(Nullable), `#`(Mutable) |
| `*?buf#` | 复杂属性示例 | `*`原始指针, `?`可空, `buf`名字, `#`字段本身可变 |
| `auto p = Point(x=1, y=2)` | 实例化 | 使用圆括号和命名参数初始化 |
| `shape Pair(i32, i32)` | 元组 (Tuple) | 匿名结构体，通过 `.0`, `.1` 访问 |
| `shape Res(Ok(T) | Err)` | 枚举 (Enum) | `\|` 分隔变体，支持关联数据 (Tagged Union) |
| `shape IntOrFloat(as i32 | as f32)` | 联合 (Union) | 内存重叠，使用 `as` 关键字 |
| `alias ID = i32` | 类型别名 | 为现有类型起别名 |
| `type ID = i32` | 类型克隆 | 以已有类型为原型声明新类型 |
| **智能指针与引用** | | |
| `auto ^u` | 独占指针 (Unique) | `^` 表示独占所有权，出作用域自动释放 |
| `auto ~s` | 共享指针 (Shared) | `~` 表示引用计数共享，自动管理生命周期 |
| `auto &r = x` | 引用 (Ref) | `&` 表示借用，不转移所有权 |
| `*val` | 取地址 (Hatting) | 获取 LValue 的 Handle (通常得到 `*`,`^`,`~` 或 `&`) |
| **原始指针与手动内存** | | |
| `auto *p` | 原始指针 (Raw) | 必须带 `*`，无所有权，无生命周期管理 |
| `unsafe alloc [N] T` | 堆内存分配 | 在堆上分配 N 个 T 类型对象，返回 `*T` |
| `unsafe free [N] p` | 堆内存释放 | 释放 `p` 指向的内存，必须指定大小 N (或类型推导) |
| `p[i]` | 指针下标访问 | 像数组一样访问第 i 个元素 |
| `*p[i]` | 指针下标偏移 | 整体表达式返回一个指针，指向第 i 个元素的内存地址，与 `*p + i*sizeof(T)` 等价 |
| `p = val` | 内存重写 | 修改指针指向内存处的值(仅限具备 soul 修改权如`*p#`) |
| `*p = *q` | 指针重绑定 | 修改指针变量本身指向的地址 (仅限 `*#p`) |
| **控制流** | | |
| `if cond { ... } else { ... }` | 条件分支 | 条件无需括号 |
| `while cond { ... }` | 循环 | 最好不要用 c 风格 for，不支持 for(;;) |
| `loop { ... break }` | 无限循环 | 必须显式 `break` |
| `for x in iter { ... }` | 迭代 | 支持实现了迭代器协议的对象 |
| `match val { ... }` | 模式匹配 | 必须穷尽所有情况 (Exhaustive) |
| `auto Variant(x) => ...` | 匹配分支 | 解构枚举变体 |
| **特殊机制** | | |
| `unsafe { ... }` | 不安全块 | 解引用原始指针、调用外部 C 函数必须在此块内 |
| `impl Type@encap { ... }` | 封装/析构 | 定义私有字段和 `drop` 析构函数 |
| `return x` | 函数返回 | 返回本地变量时自动移动 (Move)，不发生拷贝析构 |
| **成员访问** | | |
| `obj.field` | 成员访问 | 访问结构体字段或调用方法 |
| `tuple.0` | 元组访问 | 访问元组元素 |
| `arr[i]` | 数组索引 | 访问数组或切片元素 |
| `p.field` | 指针成员访问 | **推荐**：摘帽后直接点号访问 (自动解引用) |
| `obj.*field` | 读指针成员 | 读取结构体中的指针字段本身 (Handle) |
| `obj.field` | 读指针指向的灵魂数据 | 读取结构体中的指针 指向的数据字段本身 (Soul) |

## **常见误区与铁律 (AI 必读)**

| 错误写法 (Wrong) | 正确写法 (Right) | 原因/铁律 |
| :--- | :--- | :--- |
| `let x = 1` / `var x = 1` | `auto x = 1` | **铁律**：Toka 只有 `auto` 关键字声明变量。 |
| `func name()` | `fn name()` | **铁律**：函数关键字是 `fn`。 |
| `shape Point { x: i32 }` | `shape Point(x: i32)` | **铁律**：Shape 定义必须使用**圆括号** `()`。 |
| `auto p = Point{x=1}` | `auto p = Point(x=1)` | **铁律**：初始化也必须使用**圆括号** `()`。 |
| `println("Hello")` | `import std/io::println`<br>`println("Hello")` | `println` 不是内置关键字，必须从标准库导入。 |
| `x.modify()` (如果定义需要 `self#`) | `x#.modify()` | 修改自身的方法必须在调用者上加 `#`，**哪怕 x 本身是可变的**。 |
| `*p` (想解引用) | `p` | **铁律 (Hat Principle)**：Toka 中裸名 `p` 即为灵魂 (Soul)，自动解引用。`*p` 是戴帽操作，得到指针本身 (Handle)。与 C++ 相反。 |
| `*p = val` (想写内存) | `p = val` | **铁律**：写内存也是操作 Soul，直接用 `p`。`*p` 是操作 Handle (重绑定)。 |
| `p = q` (想重绑定) | `*p = *q` | **铁律**：重绑定必须操作双方的 Handle (戴帽)，如果不戴帽就是把 q 的值写给 p 指向的内存。 |
| `^p->field` | `p.field` | **abolished**: 箭头操作符已废除，直接用点号访问成员。 |
| `main() {}` | `main() -> i32 { return 0 }` | `main` 必须返回 `i32`，通常显式返回 0 (某些上下文可隐式，但测试中推荐显式)。 |

