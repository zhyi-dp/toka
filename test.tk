import "core/io";

struct Point {
    x: i32,
    y: i32,
    z: i32,
}

type PointTup = (i32, i32);

fn processPoint(p: PointTup) {
    printf("Point is (%d, %d)\n", p.0, p.1);
    return;
}

fn addx(point: Point, v: i32) -> i32 {
    let tmp = point.x + v;
    return tmp;
}

fn addtox(point#: Point, v: i32) {
    point#.x += v;
}

fn addtox_useref(&point#: Point, v: i32) {
    point#.x += v;
}

fn main() {
    let p# = Point { x = 1, y = 2 };
    let i# = 0;
    let logi# = 0;
    while (i < 3) {
        printf("[%03d]p.x is %d, loop %d\n", logi#++, p.x, i);
        p#.x = p.x + 10;
        i# = i + 1;
    }
    printf("[%03d]p.x is %d, loop %d\n", logi#++, p.x, i);
    p#.x = addx(p, 10);
    printf("[%03d]p.x is %d (after addx, should be 41)\n", logi#++, p.x);
    
    addtox(p#, 10);
    printf("[%03d]p.x is %d (after addtox, should be 51 because of In-place Capture)\n", logi#++, p.x);
    
    addtox_useref(&p#, 10);
    printf("[%03d]p.x is %d (after addtox_useref, should be 61)\n", logi#++, p.x);

    let b# = true;
    if (b) {
        printf("[%03d]bool true works\n", logi#++);
    }
    b# = false;
    if (b) {
        printf("[%03d]bool false error\n", logi#++);
    } else {
        printf("[%03d]bool false works\n", logi#++);
    }

    let f# = 3.14;
    printf("[%03d]float is %f\n", logi#++, f);

    let s = "Hello Toka";
    printf("[%03d]string is %s\n", logi#++, s);

    let arr# = [10, 20, 30];
    printf("[%03d]arr[0] is %d\n", logi#++, arr[0]);
    printf("[%03d]arr[1] is %d\n", logi#++, arr[1]);
    arr#[2] = 40;
    printf("[%03d]arr[2] is %d\n", logi#++, arr[2]);

    let tup = (1, "tuple", 1.1);
    printf("[%03d]tup.0 is %d\n", logi#++, tup.0);
    printf("[%03d]tup.1 is %s\n", logi#++, tup.1);
    printf("[%03d]tup.2 is %f\n", logi#++, tup.2);

    let pt: PointTup = (100, 200);
    processPoint(pt);

    // Reference tests following safety rules
    let a# = 10;
    {
        let &b# = &a#;
        b# = 20;
        // Accessing 'a' here would be a violation of rule 406
    }
    // Now b# is out of scope, safe to access a
    if (a == 20) {
        printf("[%03d]Reference assignment works: a is %d\n", logi#++, a);
    } else {
        printf("[%03d]Reference assignment FAILED: a is %d\n", logi#++, a);
    }

    {
        let &c = &a; // immutable ref
        printf("[%03d]Immutable ref: c is %d\n", logi#++, c);
        // rule 405: multiple immutable refs are fine, and accessing 'a' read-only is fine
        printf("[%03d]Original a is still %d\n", logi#++, a);
    }

    let d# = 100;
    printf("[%03d]Prefix ++: d is %d\n", logi#++, ++d#);
    printf("[%03d]Prefix --: d is %d\n", logi#++, --d#);

    return;
}


