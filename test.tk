import "core/io";
import "core/memory";

struct Point {
    x: i32,
    y: i32,
    z: i32,
}

type PointTup = (i32, i32);

fn processPoint(p: PointTup) {
    printf("Point is (%d, %d)\n", p.0, p.1);
    return;
}

fn addx(point: Point, v: i32) -> i32 {
    let tmp = point.x + v;
    return tmp;
}

fn addtox(point#: Point, v: i32) {
    point#.x += v;
}

fn addtox_useref(&point#: Point, v: i32) {
    point#.x += v;
}

fn main() -> i32 {
    let p# = Point { x = 1, y = 2, z = 111 };
    let i# = 0;
    let logi# = 0;
    while (i < 3) {
        printf("[%03d]p.x is %d, loop %d\n", logi#++, p.x, i);
        p#.x = p.x + 10;
        i# = i + 1;
    }
    printf("[%03d]p.x is %d, loop %d\n", logi#++, p.x, i);
    p#.x = addx(p, 10);
    printf("[%03d]p.x is %d (after addx, should be 41)\n", logi#++, p.x);
    
    addtox(p#, 10);
    printf("[%03d]p.x is %d (after addtox, should be 51 because of In-place Capture)\n", logi#++, p.x);
    
    addtox_useref(&p#, 10);
    printf("[%03d]p.x is %d (after addtox_useref, should be 61)\n", logi#++, p.x);

    let b# = true;
    if (b) {
        printf("[%03d]bool true works\n", logi#++);
    }
    b# = false;
    if (b) {
        printf("[%03d]bool false error\n", logi#++);
    } else {
        printf("[%03d]bool false works\n", logi#++);
    }

    let f# = 3.14;
    printf("[%03d]float is %f\n", logi#++, f);

    let s = "Hello Toka";
    printf("[%03d]string is %s\n", logi#++, s);

    let arr# = [10, 20, 30];
    printf("[%03d]arr[0] is %d\n", logi#++, arr[0]);
    printf("[%03d]arr[1] is %d\n", logi#++, arr[1]);
    arr#[2] = 40;
    printf("[%03d]arr[2] is %d\n", logi#++, arr[2]);

    let tup = (1, "tuple", 1.1);
    printf("[%03d]tup.0 is %d\n", logi#++, tup.0);
    printf("[%03d]tup.1 is %s\n", logi#++, tup.1);
    printf("[%03d]tup.2 is %f\n", logi#++, tup.2);

    let pt: PointTup = (100, 200);
    processPoint(pt);

    let PointTup(tup0, tup1) = pt;
    printf("[%03d]tup0 is %d\n", logi#++, tup0);
    printf("[%03d]tup1 is %d\n", logi#++, tup1);

    let Point(v0, v1, v2) = p;
    printf("[%03d]v0 is %d\n", logi#++, v0);
    printf("[%03d]v1 is %d\n", logi#++, v1);
    printf("[%03d]v2 is %d\n", logi#++, v2);

    // Reference tests following safety rules
    let a# = 10;
    {
        let &b# = &a#;
        b# = 20;
        // Accessing 'a' here would be a violation of rule 406
    }
    // Now b# is out of scope, safe to access a
    if (a == 20) {
        printf("[%03d]Reference assignment works: a is %d\n", logi#++, a);
    } else {
        printf("[%03d]Reference assignment FAILED: a is %d\n", logi#++, a);
    }

    {
        let &c = &a; // immutable ref
        printf("[%03d]Immutable ref: c is %d\n", logi#++, c);
        // rule 405: multiple immutable refs are fine, and accessing 'a' read-only is fine
        printf("[%03d]Original a is still %d\n", logi#++, a);
    }

    let d# = 100;
    printf("[%03d]Prefix ++: d is %d\n", logi#++, ++d#);
    printf("[%03d]Prefix --: d is %d\n", logi#++, --d#);

    {
        printf("Testing Raw pointer...\n");
        let *ptr = new Point{x=999, y=111, z=0};
        printf("[%03d]Raw Heap Point: ptr.x=%d, address=%p\n", logi#++, ptr.x, *ptr);
        del *ptr;
    }

    // Heap Allocation Test
    let ^heapNode = new Point{x = 777, y = 888, z = 0};
    printf("[%03d]Heap Point is (%d, %d)\n", logi#++, heapNode.x, heapNode.y);

    {
        printf("Testing Move Semantics...\n");
        let ^p = new Point{x=999, y=111, z=0};
        let ^q = ^p;
        printf("[%03d]Moved Heap Point: q.x=%d\n", logi#++, q.x);
    }

    {
        printf("Testing Shared Semantics...\n");
        let ~s1# = new Point{x = 1000, y = 2000, z = 0};
        let ~s2 = ~s1; // Shared Copy (ref++)
        s1#.x = 3000;
        printf("[%03d]Shared s1.x=3000\n", logi#++);
        if (s2.x == 3000) {
            printf("[%03d]Shared s2.x sees change (3000)\n", logi#++);
        } else {
            printf("FAIL: s2.x not updated\n");
        }
    }

    printf("main() done\n");
    return 0;
}


